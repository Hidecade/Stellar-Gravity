<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Stellar Gravity</title>
    <meta name="apple-mobile-web-app-title" content="StellarGrav">


    <link rel="icon" href="img/StellarGravity.ico" type="image/x-icon">

    <link rel="apple-touch-icon" href="img/icon.png">

    <link rel="icon" type="image/png" sizes="192x192" href="img/StellarGravity.png">


    <!-- =========================================================
         Physics Engine
         - Matter.js（重力・衝突・剛体など）
         ========================================================= -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <style>
        /* =========================================================
           Global / Layout
           ========================================================= */
        body {
            margin: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            font-family: "Courier New", sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
            position: fixed; /* スクロールによるガタつきを防止 */
            overflow: hidden;
        }

        /* Matter.js canvas (full-screen fixed) */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: block;
            -webkit-touch-callout: none; /* 長押しによるメニュー（画像保存など）を禁止 */
        }



        /* =========================================================
           HUD (score / next)
           - pointer-events:none で操作を邪魔しない
           ========================================================= */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            margin-bottom: 10px;
        }

        .score-num {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 15px #4facfe;
            font-family: Arial, sans-serif;
        }

        .hi-score-num {
            font-size: 40px;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241,196,15,0.5);
            font-family: Arial, sans-serif;
        }

        /* =========================================================
           Overlay (title / game over / clear)
           ========================================================= */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s;
            pointer-events: auto;
        }

            #overlay.hide {
                opacity: 0;
                pointer-events: none;
            }

        h1 {
            margin: 0;
            font-size: 42px;
            line-height: 1.1;
            letter-spacing: 6px;
            font-weight: 300;
        }

        .btn {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.8);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            letter-spacing: 4px;
            pointer-events: auto;
        }

            .btn:hover {
                background: white;
                color: black;
            }

        /* =========================================================
           BOOST Button (visual / hit target)
           ========================================================= */
        #boost-btn {
            position: fixed;
            bottom: 32px;
            left: 32px;
            /* button body */
            padding: 6px 16px;
            font-size: 22px;
            letter-spacing: 2px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 20px;
            cursor: pointer;
            z-index: 20;
            user-select: none;
            -webkit-user-select: none;
            /* subtle inner glow */
            box-shadow: inset 0 0 12px rgba(255,255,255,0.25);
            isolation: isolate;
            cursor: pointer;
        }

            /* Outer large frame (main highlight) */
            #boost-btn::before {
                content: "";
                position: absolute;
                inset: -18px;
                border-radius: 120px;
                border: 4px solid rgba(79,172,254,0.9);
                box-shadow: 0 0 30px rgba(79,172,254,0.6), 0 0 70px rgba(79,172,254,0.4);
                pointer-events: none;
                z-index: -1;
            }

        .boosting {
            box-shadow: 0 0 20px rgba(79,172,254,0.9);
        }

        /* =========================================================
           Stage UI (bottom-right)
           ========================================================= */
        #stage-ui {
            position: fixed;
            right: 24px;
            bottom: 24px;
            text-align: right;
            z-index: 15;
            pointer-events: none;
        }

        .stage-label {
            font-size: 20px;
            letter-spacing: 2px;
            color: #aaa;
        }

        .stage-num {
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(255,255,255,0.6);
            font-family: Arial, sans-serif;
        }

        .hi-stage {
            margin-left: 12px;
            font-size: 18px;
            color: #aaa;
            letter-spacing: 1px;
        }

        /* NEXT label text (currently hidden) */
        #next-name {
            opacity: 0.85;
            text-shadow: 0 0 6px rgba(255,255,255,0.4);
            display: block;
        }

        /* Overlay sub buttons */
        .sub-btn {
            margin-top: 16px;
            padding: 10px 36px;
            font-size: 14px;
            letter-spacing: 3px;
            opacity: 0.75;
            border-color: rgba(255,255,255,0.5);
        }

            .sub-btn:hover {
                opacity: 1;
                background: rgba(255,255,255,0.15);
                color: white;
            }

        /* BGM toggle (title screen only; placed inside overlay) */
        #bgm-toggle {
            position: fixed;
            left: 70%;
            bottom: 18px;
            transform: translateX(-50%);
            z-index: 18;
            padding: 6px 20px;
            font-size: 12px;
            letter-spacing: 2px;
            background: rgba(0,0,0,0.45);
            color: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 999px;
            opacity: 0.6;
        }

            #bgm-toggle:hover {
                opacity: 1;
            }

        #reset-btn {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 16px;
            min-width: 80px;
            min-height: 36px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            letter-spacing: 1px;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 999999;
            pointer-events: auto;
            display: none;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.2);
            transition: background 0.2s ease, transform 0.1s ease;
        }

            #reset-btn:active {
                background: rgba(60, 60, 60, 0.9);
                transform: translateX(-50%) scale(0.96);
            }
    </style>

</head>

<body>

    <!-- =========================================================
         BGM (loop)
         ========================================================= -->
    <audio id="bgm" src="audio/StellarGravity_01.mp3" loop preload="auto"></audio>
    <audio id="clear-bgm" src="audio/StellarGravity_Clear.mp3" preload="auto"></audio>


    <!-- Matter.js canvas is injected here -->
    <div id="canvas-container"></div>

    <!-- =========================================================
         HUD
         ========================================================= -->
    <div id="ui-layer" style="padding: 20px 10px 20px 20px;">
        <div style="text-align:left;">
            <div class="hud-item">
                <span style="font-size:20px;color:#aaa;">HIGH SCORE</span><br />
                <span id="hi-score-val" class="hi-score-num">0</span>
                <span class="hi-stage">STAGE <span id="hi-stage-val">1</span></span>
            </div>
            <div class="hud-item">
                <span style="font-size:20px;color:#aaa;">SCORE</span><br />
                <span id="score-val" class="score-num">0</span>
            </div>
        </div>

        <div style="text-align: right; margin-right: -5px;">
            <div style="display: inline-flex; flex-direction: column; align-items: center; min-width: 100px;">
                <span style="font-size:20px; color:#aaa; letter-spacing:2px; margin-bottom: 2px;">NEXT</span>

                <div id="next-ui" style="height:55px; width:60px; margin: 0 auto;"></div>

                <div id="next-name"
                     style="margin-top: 2px; font-size:15px; letter-spacing:1px; font-weight: bold; line-height: 1.1;">
                </div>
            </div>
        </div>
    </div>

    <!-- =========================================================
         Overlay (title / result)
         - BGM ON/OFF is title-screen-only (inside overlay)
         ========================================================= -->
    <div id="overlay">
        <h1 id="title-text">STELLAR<br />GRAVITY</h1>

        <button id="start-btn" class="btn">START</button>

        <button id="clear-hi-btn" class="btn sub-btn">
            CLEAR HIGH SCORE
        </button>

        <button id="bgm-toggle" class="btn sub-btn" style="margin-top:24px;">
            BGM ON
        </button>

        <p id="clear-message"
           style="
     margin-top:20px;
     font-size:16px;
     letter-spacing:1px;
     opacity:0.9;
     display:none;
   ">
        </p>

    </div>

    <!-- =========================================================
         BOOST
         ========================================================= -->
    <div style="margin-top: 12px; pointer-events: auto;">
        <button id="boost-btn">
            BOOST
        </button>
    </div>

    <!-- Stage display (bottom-right) -->
    <div id="stage-ui">
        <div class="stage-label">STAGE</div>
        <div id="stage-val" class="stage-num">1</div>
    </div>

    <button id="reset-btn">RESET</button>



    <script>
        /* =========================================================
         * Stellar Gravity
         * ---------------------------------------------------------
         * Game Summary:
         * - Center core (sun-like)
         * - Launcher rotates around center automatically
         * - Tap/click to shoot a planet toward center
         * - Same size (same index) merges into next level
         * - If any planet stays outside DEADLINE for 3 sec -> Game Over
         * - Grow to BlackHole -> Clear
         * ========================================================= */

        /* =========================================================
         * iOS 判定（起動時に1回だけ）
         * ========================================================= */
        const isIOS =
            /iPhone|iPad|iPod/.test(navigator.userAgent) ||
            (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);


        /* =========================================================
         * Constants / Tuning
         * ========================================================= */
        const SUPERNOVA_BONUS = 3000;
        const SUPERNOVA_CLEAR_DELAY = 450;
        const SUPERNOVA_END_DELAY = 1100;

        const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;



        /* =========================================================
         * ゲーム変数
         * ========================================================= */
        let isClearing = false;
        let isPaused = false;

        const bgm = document.getElementById("bgm");
        const clearBgm = document.getElementById("clear-bgm");


        /* =========================================================
         * Screen / Center
         * ========================================================= */
        let WIDTH = window.innerWidth;
        let HEIGHT = window.innerHeight;
        let CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };

        /* =========================================================
         * Difficulty Radii
         * - CORE_RADIUS:   center core radius
         * - DEADLINE_RADIUS: danger threshold
         * - SPAWN_RADIUS: launcher distance from center
         * ========================================================= */
        const DEADLINE_RADIUS = 180;
        const SPAWN_RADIUS = 220;

        // RedZone visual tuning
        const REDZONE_ROT_SPEED = 0.0015;   // 回転速度
        const REDZONE_SPARK_RATE = 0.12;    // 火花発生率


        /* Core growth on stage clear */
        const CORE_DEFAULT = 25;
        const CORE_MAX = 70;
        const CORE_GROW = 10;
        let CORE_RADIUS = CORE_DEFAULT;

        /* State flags related to stage clear / continue */
        let pendingCoreBoost = false;
        let isContinue = false;


        /* =========================================================
         * Rotation Boost
         * ========================================================= */
        let isBoosting = false;
        const ROTATE_BASE_SPEED = 0.015;
        const ROTATE_BOOST_MULT = 3.5;
        const STAR_BOOST_MULT = 3.0;
        const STAR_BASE_SPEED = 6.0; 

        let clearCount = 0;
        let difficulty = 1.0;

        const DIFF_STEP = 0.12;   // 1クリアごとの上昇量
        const DIFF_MAX = 3.0;    // 上限
        /* =========================================================
         * Stage / Hi-Stage
         * ========================================================= */
        let stage = 1;
        document.getElementById("stage-val").innerText = stage;

        let hiStage = localStorage.getItem("stellarGravity_hiStage") || 1;
        document.getElementById("hi-stage-val").innerText = hiStage;

        /* =========================================================
         * Planet Definitions (merge levels)
         * index: 0..8
         * score: points gained when the higher planet is created
         * ========================================================= */
        const PLANETS = [
            { name: "W.Dwarf", radius: 10, color: "#aab7b8", score: 1 },  // 灰色：冷えゆく白色矮星
            { name: "Sirius.B", radius: 16, color: "#dfe6e9", score: 2 },     // 明るい灰：シリウスの伴星（白色矮星）
            { name: "B.Star", radius: 22, color: "#ff7675", score: 4 }, // 薄赤：バーナード星（赤色矮星）
            { name: "Vega", radius: 30, color: "#74b9ff", score: 8 },         // 青：こと座のベガ（青白い主系列星）
            { name: "Capella", radius: 38, color: "#a29bfe", score: 16 },    // 紫：カペラ（黄色〜紫がかった巨星のイメージ）
            { name: "Procyon", radius: 48, color: "#ffeaa7", score: 32 },    // 薄黄：プロキオン（黄白色の準巨星）
            { name: "Arcturus", radius: 58, color: "#fab1a0", score: 64 },   // 橙：アークトゥルス（オレンジ色の巨星）
            { name: "Antares", radius: 70, color: "#ff9f43", score: 128 },   // 輝く橙：アンタレス（赤色超巨星）
            { name: "BlackHole", radius: 85, color: "#ffffff", score: 256 }  // 白：ブラックホールのイベントホライズン
        ];

        /* =========================================================
         * Game State
         * ========================================================= */
        let engine, render, runner;

        let score = 0;
        let hiScore = localStorage.getItem("stellarGravity_hiScore") || 0;

        let isGameRunning = false;
        let isClickable = true;
        let nextQueue = [];
        let launcherAngle = -Math.PI / 2;

        let gameOverTime = null;
        let particles = [];
        let bgStars = [];


        // ★ デバッグ用：どの惑星でクリアするか
        const DEBUG_CLEAR_INDEX = 3; // Earth
        // 本番は ↓
        const CLEAR_INDEX = PLANETS.length - 1; // BlackHole
        let isBlackHoleCore = false;

        // コンボ管理用の変数
        let lastMergeTime = 0;
        let comboCount = 0;

        /* =========================================================
         * クリア時に呼ぶ
         * ========================================================= */
        function onClear() {
            clearCount++;
            difficulty = Math.min(DIFF_MAX, 1.0 + clearCount * DIFF_STEP);
        }

        /* =========================================================
         * 回転速度
         * ========================================================= */
        function applyRotation(body) {
            const base = ROTATE_BASE_SPEED * difficulty;

            const rotateSpeed = isBoosting
                ? base * ROTATE_BOOST_MULT
                : base;

            Body.setAngularVelocity(body, rotateSpeed);
        }

        function applyStarBoost(body, angle) {
            const speed =
                STAR_BASE_SPEED *
                STAR_BOOST_MULT *
                difficulty;

            Body.setVelocity(body, {
                x: Math.sin(angle) * speed,
                y: Math.cos(angle) * speed
            });
        }

        function clamp(v, min, max) {
            return Math.min(max, Math.max(min, v));
        }


        /* =========================================================
         * requestFullScreen
         * ========================================================= */
        function requestFullScreen() {
            const el = document.documentElement;

            // 標準のAPI（AndroidやiPad用）
            if (el.requestFullscreen) {
                el.requestFullscreen();
            } else if (el.webkitRequestFullscreen) {
                el.webkitRequestFullscreen();
            } else if (isIOS) {
                // iPhone Safari用の擬似全画面対策
                window.scrollTo(0, 0); // アドレスバーを隠すためのスクロール
            }
        }


        /* =========================================================
         * ゲームタイトルに戻る
         * ========================================================= */
        function returnToTitle() {

            // 物理演算を完全停止
            Runner.stop(runner);

            isGameRunning = false;
            isPaused = false;
            isClickable = false;

            stopBGM();

            // ワールドの完全クリア
            Composite.clear(engine.world, false);

            // ★ ここが超重要：再スタート時にrunnerを再起動できるように
            Runner.run(runner, engine);

            const overlay = document.getElementById("overlay");
            overlay.classList.remove("hide");

            document.querySelector("#overlay h1").innerHTML = "STELLAR<br>GRAVITY";
            document.getElementById("start-btn").textContent = "START";

            document.getElementById("clear-message").style.display = "none";

            bgmToggleBtn.style.pointerEvents = "auto";
            bgmToggleBtn.style.opacity = "0.75";

            updateResetButtonVisibility();
        }



        /* =========================================================
         * Audio (WebAudio for SFX)
         * ========================================================= */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let noiseBuffer = null;

        document.getElementById("hi-score-val").innerText = hiScore;

        // SFX用マスターゲイン
        const sfxMasterGain = audioCtx.createGain();
        sfxMasterGain.gain.value = 1.8;   // ← ここで効果音全体を大きく
        sfxMasterGain.connect(audioCtx.destination);


        /* =========================================================
         * Utility: BOOST safe area (avoid mis-tap shooting)
         * ========================================================= */
        function isInBoostSafeArea(clientX, clientY) {
            const rect = boostBtn.getBoundingClientRect();
            const margin = 60;

            return (
                clientX >= rect.left - margin &&
                clientX <= rect.right + margin &&
                clientY >= rect.top - margin &&
                clientY <= rect.bottom + margin
            );
        }

        /* =========================================================
         * Noise buffer (for suction / explosion ambience)
         * ========================================================= */
        function createNoiseBuffer() {
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }

        /* =========================================================
         * SFX: suction sound
         * ========================================================= */
        function playSuctionSound() {
            const t = audioCtx.currentTime;
            const drum = audioCtx.createOscillator(), g = audioCtx.createGain();

            drum.type = 'sine';

            // ★ 音程アップ
            drum.frequency.setValueAtTime(140, t);                // 100 → 140
            drum.frequency.exponentialRampToValueAtTime(45, t + 1.5); // 30 → 45

            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.6, t + 0.1);         // 少し音量も整理
            g.gain.exponentialRampToValueAtTime(0.001, t + 1.8);

            drum.connect(g);
            g.connect(sfxMasterGain);
            drum.start(t);
            drum.stop(t + 1.8);

            if (!noiseBuffer) noiseBuffer = createNoiseBuffer();
            const burst = audioCtx.createBufferSource();
            burst.buffer = noiseBuffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';

            // ★ ノイズも少し明るく
            filter.frequency.setValueAtTime(220, t); // 150 → 220

            const nG = audioCtx.createGain();
            nG.gain.setValueAtTime(0.12, t);
            nG.gain.exponentialRampToValueAtTime(0.001, t + 1.2);

            burst.connect(filter);
            filter.connect(nG);
            nG.connect(sfxMasterGain);

            burst.start(t);
            burst.stop(t + 1.2);
        }


        /* =========================================================
         * SFX: heavy explosion (merge)
         * ========================================================= */
        function playExplosionSound() {
            if (audioCtx.state === "suspended") audioCtx.resume();
            const t = audioCtx.currentTime;

            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(180, t);
            osc.frequency.exponentialRampToValueAtTime(60, t + 0.45);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.0001, t);
            gain.gain.exponentialRampToValueAtTime(0.9, t + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.7);

            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer || (noiseBuffer = createNoiseBuffer());

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = "lowpass";
            noiseFilter.frequency.setValueAtTime(400, t);

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.15, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);

            const delay = audioCtx.createDelay(0.6);
            delay.delayTime.setValueAtTime(0.12, t);

            const feedback = audioCtx.createGain();
            feedback.gain.setValueAtTime(0.25, t);

            delay.connect(feedback);
            feedback.connect(delay);

            osc.connect(gain);
            gain.connect(sfxMasterGain);

            gain.connect(delay);
            delay.connect(sfxMasterGain);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(sfxMasterGain);

            osc.start(t);
            osc.stop(t + 0.8);

            noise.start(t);
            noise.stop(t + 0.5);
        }

        /* =========================================================
         * SFX: black hole (clear)
         * ========================================================= */
        function playBlackHoleSound() {
            if (audioCtx.state === "suspended") audioCtx.resume();
            const t = audioCtx.currentTime;

            const osc1 = audioCtx.createOscillator();
            osc1.type = "triangle";
            osc1.frequency.setValueAtTime(42, t + 0.3);
            osc1.frequency.exponentialRampToValueAtTime(18, t + 2.2);

            const gain1 = audioCtx.createGain();
            gain1.gain.setValueAtTime(0.0001, t);
            gain1.gain.exponentialRampToValueAtTime(0.45, t + 0.6);
            gain1.gain.exponentialRampToValueAtTime(0.0001, t + 2.4);

            const lfo = audioCtx.createOscillator();
            lfo.type = "sine";
            lfo.frequency.setValueAtTime(6, t);

            const lfoGain = audioCtx.createGain();
            lfoGain.gain.setValueAtTime(14, t);

            lfo.connect(lfoGain);
            lfoGain.connect(osc1.frequency);

            const boom = audioCtx.createOscillator();
            boom.type = "sine";
            boom.frequency.setValueAtTime(60, t + 2.3);
            boom.frequency.exponentialRampToValueAtTime(28, t + 2.55);

            const boomGain = audioCtx.createGain();
            boomGain.gain.setValueAtTime(0.0001, t + 2.25);
            boomGain.gain.exponentialRampToValueAtTime(1.0, t + 2.35);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, t + 2.9);

            osc1.connect(gain1);
            gain1.connect(sfxMasterGain);

            boom.connect(boomGain);
            boomGain.connect(sfxMasterGain);

            osc1.start(t + 0.3);
            osc1.stop(t + 2.5);

            lfo.start(t);
            lfo.stop(t + 2.5);

            boom.start(t + 2.25);
            boom.stop(t + 3.0);
        }

        /* =========================================================
         * Drawing: planet (custom glow)
         * ========================================================= */
        function drawPlanet(ctx, x, y, r, color, time, bodyId) {
            ctx.save();
            ctx.translate(x, y);

            const pulse = Math.sin(time * 0.003 + bodyId) * 0.05 + 0.95;
            const curR = r * pulse;

            for (let i = 0; i < 3; i++) {
                const shift = Math.sin(time * 0.002 + (i * 2) + bodyId) * (r * 0.15);
                ctx.beginPath();
                ctx.arc(0, 0, curR + shift + (i * 2), 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.35 - (i * 0.1);
                ctx.fill();
            }

            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.arc(0, 0, curR, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = curR * 1.5;
            ctx.fill();

            ctx.restore();
        }

        /* =========================================================
         * Background stars
         * ========================================================= */
        const STAR_COUNT = Math.floor(80 * 1.5);
        const STAR_SIZE_MIN = 0.4;
        const STAR_SIZE_MAX = 3.0;

        const STAR_WHITE_RATIO = 0.65;
        const STAR_HUE_MIN = 180;
        const STAR_HUE_MAX = 320;
        const STAR_SAT = 90;
        const STAR_LIT = 80;

        function generateStars() {
            bgStars = [];

            for (let i = 0; i < STAR_COUNT; i++) {
                const isWhite = Math.random() < STAR_WHITE_RATIO;
                const alpha = 0.25 + Math.random() * 0.75;

                let color;
                if (isWhite) {
                    color = `rgba(235, 245, 255, ${alpha})`;
                } else {
                    const hue = STAR_HUE_MIN + Math.random() * (STAR_HUE_MAX - STAR_HUE_MIN);
                    color = `hsla(${hue}, ${STAR_SAT}%, ${STAR_LIT}%, ${alpha})`;
                }

                bgStars.push({
                    r: Math.random() * Math.max(WIDTH, HEIGHT),
                    angle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.006 + 0.004,
                    size: STAR_SIZE_MIN + Math.random() * (STAR_SIZE_MAX - STAR_SIZE_MIN),
                    color
                });
            }
        }

        /* =========================================================
         * Pre-initialize world / renderer / loop events
         * ========================================================= */
        function preInit() {
            generateStars();

            engine = Engine.create({ gravity: { x: 0, y: 0, scale: 0 } });

            render = Render.create({
                element: document.getElementById("canvas-container"),
                engine: engine,
                options: {
                    width: WIDTH,
                    height: HEIGHT,
                    wireframes: false,
                    background: "transparent"
                }
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            /* =====================================================
             * Render loop: afterRender
             * - rotate launcher
             * - draw background / guideline / core / planets / particles
             * - deadline + game over check
             * ===================================================== */
            Events.on(render, "afterRender", () => {
                const ctx = render.context;
                const now = Date.now();

                if (isGameRunning) {
                    const base = ROTATE_BASE_SPEED * difficulty;
                    const speed = isBoosting
                        ? base * ROTATE_BOOST_MULT
                        : base;
                    launcherAngle += speed;
                }


                // 1. まず現在の恒星名を表示するロジック（恒星名が正しく出るように）
                if (nextQueue.length >= 2) {
                    const nextPlanet = PLANETS[nextQueue[1]];
                    document.getElementById("next-name").textContent = nextPlanet.name;
                    document.getElementById("next-name").style.color = nextPlanet.color; // 名前も星の色に合わせると綺麗です
                }

                /* background stars */
                bgStars.forEach(s => {
                    const mult = isBoosting ? STAR_BOOST_MULT : 1.0;
                    s.angle += s.speed * mult;

                    ctx.save();
                    ctx.fillStyle = s.color;
                    ctx.beginPath();
                    ctx.arc(
                        CENTER.x + Math.cos(s.angle) * s.r,
                        CENTER.y + Math.sin(s.angle) * s.r,
                        s.size,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    ctx.restore();
                });

                ctx.globalAlpha = 1;

                /* =====================================================
                 * RedZone (animated dash rotation) & Warning Logic
                 * ===================================================== */
                const t = performance.now();

                // ★ 追加: 警告状態の判定
                const isWarning = gameOverTime !== null;

                ctx.save();
                ctx.translate(CENTER.x, CENTER.y);

                ctx.beginPath();
                ctx.arc(0, 0, DEADLINE_RADIUS, 0, Math.PI * 2);
                ctx.setLineDash([10, 14]);

                // 回転
                ctx.lineDashOffset = -(t * 0.02) % 1000;

                // ★ 修正: 点滅ロジックの強化
                // 警告時はベースの透明度を上げ、周期を速くする
                const blinkBase = isWarning ? 0.7 : 0.3;
                const blinkFreq = isWarning ? 0.015 : 0.006;
                const blink = blinkBase + (1 - blinkBase) * (0.5 + 0.5 * Math.sin(t * blinkFreq));

                ctx.strokeStyle = isWarning ? `rgba(255, 0, 0, ${blink})` : `rgba(255, 60, 60, ${blink})`;
                ctx.lineWidth = isWarning ? 4 : 2; // 警告時は線を太く
                ctx.stroke();

                // 外側グロー
                ctx.beginPath();
                ctx.setLineDash([]);
                ctx.arc(0, 0, DEADLINE_RADIUS + 3, 0, Math.PI * 2);
                // 警告時はグローも赤く強くする
                ctx.strokeStyle = isWarning ? `rgba(255, 0, 0, ${blink * 0.5})` : "rgba(255, 80, 80, 0.25)";
                ctx.lineWidth = isWarning ? 10 : 6;
                ctx.stroke();

                ctx.restore();


                /* =====================================================
                 * RedZone sparks
                 * ===================================================== */
                // ★ 修正: 警告時は火花の発生率を上げる
                const SPARK_RATE = isWarning ? 0.8 : (isIOS ? 0.25 : 0.45);
                const SPARK_MAX = 220;

                if (particles.length > SPARK_MAX) particles.splice(0, particles.length - SPARK_MAX);

                if (Math.random() < SPARK_RATE) {
                    const burst = 2 + (isBoosting ? 4 : 2);

                    for (let k = 0; k < burst; k++) {
                        const ang = Math.random() * Math.PI * 2;
                        const r = DEADLINE_RADIUS + (Math.random() * 10 - 5);
                        const x = CENTER.x + Math.cos(ang) * r;
                        const y = CENTER.y + Math.sin(ang) * r;

                        const sp = (isBoosting ? 5.0 : 3.2) * (0.6 + Math.random() * 0.8);
                        const ox = Math.cos(ang) * sp + (Math.random() - 0.5) * 1.0;
                        const oy = Math.sin(ang) * sp + (Math.random() - 0.5) * 1.0;

                        particles.push({
                            type: "spark",
                            x, y,
                            px: x, py: y,
                            vx: ox,
                            vy: oy,
                            life: 1.0,
                            size: 1.5 + Math.random() * 2.5,
                            color: isWarning ? "rgba(255, 255, 255, 1)" : "rgba(255,60,60,1)" // 警告時は白混ぜて輝かせる
                        });
                    }
                }



                /* core (star / black hole) */
                ctx.save();
                ctx.translate(CENTER.x, CENTER.y);

                if (!isBlackHoleCore) {
                    // ===== 通常の恒星 =====
                    const gR = CORE_RADIUS * 3 + Math.sin(now * 0.008) * 5;
                    const grad = ctx.createRadialGradient(0, 0, CORE_RADIUS, 0, 0, gR);
                    grad.addColorStop(0, "rgba(255, 120, 50, 0.9)");
                    grad.addColorStop(1, "rgba(255, 0, 0, 0)");
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, gR, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, CORE_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = "#fff700";
                    ctx.fill();
                } else {
                    // ===== ブラックホール =====

                    const t2 = performance.now() * 0.002;

                    // 外側フレア（赤）
                    for (let i = 0; i < 6; i++) {
                        const r = CORE_RADIUS * (1.8 + i * 0.25);
                        const a = 0.15 + Math.sin(t2 + i) * 0.1;

                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255,80,40,${a})`;
                        ctx.lineWidth = 6;
                        ctx.stroke();
                    }

                    // 内部グラデーション（暗赤 → 黒）
                    const holeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, CORE_RADIUS);
                    holeGrad.addColorStop(0, "rgba(0,0,0,1)");
                    holeGrad.addColorStop(0.6, "rgba(30,0,0,0.9)");
                    holeGrad.addColorStop(1, "rgba(0,0,0,1)");

                    ctx.fillStyle = holeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, CORE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();


                /* draw planets (custom) */
                Composite.allBodies(engine.world).forEach(b => {
                    if (!b.isStatic && b.index !== undefined) {
                        drawPlanet(ctx, b.position.x, b.position.y, b.circleRadius, PLANETS[b.index].color, now, b.id);
                    }
                });

                /* launcher guide + next preview */
                if (isGameRunning) {
                    // 1. 発射台（ランチャー）の描画
                    if (isClickable) {
                        const sX = CENTER.x + Math.cos(launcherAngle) * SPAWN_RADIUS;
                        const sY = CENTER.y + Math.sin(launcherAngle) * SPAWN_RADIUS;

                        ctx.save();
                        ctx.beginPath();
                        ctx.setLineDash([4, 6]);
                        ctx.strokeStyle = "rgba(180, 180, 180, 0.5)";
                        ctx.lineWidth = 1.5;
                        ctx.moveTo(sX, sY);
                        ctx.lineTo(CENTER.x, CENTER.y);
                        ctx.stroke();
                        ctx.restore();

                        // 発射待機中の星を描画
                        drawPlanet(ctx, sX, sY, PLANETS[nextQueue[0]].radius, PLANETS[nextQueue[0]].color, now, 0);
                    }

                    // 2. 右上の NEXT プレビュー（恒星名・星画像をセンタリング）
                    if (nextQueue.length >= 2) {
                        const nextPlanet = PLANETS[nextQueue[1]];

                        // --- 恒星名と色の更新 ---
                        const nameEl = document.getElementById("next-name");
                        if (nameEl) {
                            nameEl.textContent = nextPlanet.name;
                            nameEl.style.color = nextPlanet.color;
                        }

                        // --- 恒星画像の描画（HTMLのnext-ui位置を自動取得） ---
                        const nextUiEl = document.getElementById("next-ui");
                        if (nextUiEl) {
                            const rect = nextUiEl.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;

                            ctx.save();
                            ctx.translate(centerX, centerY);
                            // 右端で窮屈に見えるなら、倍率を 0.7 程度に下げると余白が生まれます
                            drawPlanet(ctx, 0, 0, nextPlanet.radius * 0.7, nextPlanet.color, now, 1);
                            ctx.restore();
                        }
                    }
                }

                /* particles */
                /* particles loop */
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];

                    // 1. 寿命（life）の減衰を一括管理
                    if (p.type === "flash") {
                        p.life -= 0.07;
                    } else if (p.type === "spark") {
                        p.life -= 0.04;
                    } else {
                        p.life -= 0.02;
                    }

                    // 2. 寿命が尽きたらその場で削除して次のループへ
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    // 3. 座標の更新（共通処理）
                    p.px = p.x; // spark用に前の座標を保存（軌跡用）
                    p.py = p.y;
                    p.x += (p.vx || 0);
                    p.y += (p.vy || 0);

                    // 4. タイプ別の描画処理
                    if (p.type === "shockwave") {
                        p.radius += (p.speed || 0) * 0.5;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255,255,255,${p.life})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();

                    } else if (p.type === "flash") {
                        ctx.save();
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color || "rgba(255,255,255,1)";
                        ctx.fillRect(0, 0, WIDTH, HEIGHT);
                        ctx.restore();

                    } else if (p.type === "spark") {
                        ctx.save();
                        ctx.globalCompositeOperation = "lighter";
                        ctx.globalAlpha = p.life;

                        // 赤いストリーク（線）
                        ctx.strokeStyle = p.color || "rgba(255,60,60,1)";
                        ctx.lineWidth = 2.2;
                        ctx.beginPath();
                        ctx.moveTo(p.px, p.py);
                        ctx.lineTo(p.x, p.y);
                        ctx.stroke();

                        // コア（点）
                        ctx.fillStyle = "rgba(255,120,120,1)";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                    } else {
                        // 通常のパーティクル
                        ctx.save();
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                /* =====================================================
                 * Game Over Check
                 * - if any planet center goes outside DEADLINE for > 3s
                 * ===================================================== */
                let isOut = false;
                Composite.allBodies(engine.world).forEach(b => {
                    if (!b.isStatic && b.index !== undefined) {
                        const d = Math.sqrt((b.position.x - CENTER.x) ** 2 + (b.position.y - CENTER.y) ** 2);
                        if (d > DEADLINE_RADIUS) isOut = true;
                    }
                });

                if (isOut && isGameRunning) {
                    if (!gameOverTime) gameOverTime = now;
                    if (now - gameOverTime > 3000) triggerGameOver();
                } else {
                    gameOverTime = null;
                }
            });

            /* =====================================================
             * Physics loop: beforeUpdate
             * - apply custom gravity toward CENTER
             * ===================================================== */
            Events.on(engine, "beforeUpdate", () => {
                Composite.allBodies(engine.world).forEach(b => {
                    if (b.isStatic) return;
                    const dx = CENTER.x - b.position.x;
                    const dy = CENTER.y - b.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const force = 0.0028 * b.mass;

                    Body.applyForce(b, b.position, { x: (dx / dist) * force, y: (dy / dist) * force });
                });
            });

            /* =====================================================
             * Helpers: remove all dynamic bodies
             * ===================================================== */
            function removeAllDynamicBodies() {
                const bodies = Composite.allBodies(engine.world).filter(b => !b.isStatic);
                if (bodies.length) Composite.remove(engine.world, bodies);
            }

            /* =====================================================
             * Supernova effect (BlackHole clear)
             * ===================================================== */
            function triggerSupernovaAt(x, y, color = "#ffffff") {

                particles.push({ type: "flash", life: 1.0, color: "rgba(255,255,255,1)" });
                setTimeout(() => {
                    particles.push({ type: "flash", life: 0.6, color: "rgba(255,200,150,0.8)" });
                }, 120);
                setTimeout(() => {
                    particles.push({ type: "flash", life: 0.35, color: "rgba(255,120,80,0.6)" });
                }, 300);

                const waves = [
                    { r: 10, sp: 10, life: 1.2 },
                    { r: 40, sp: 8, life: 1.1 },
                    { r: 90, sp: 6, life: 1.0 },
                    { r: 160, sp: 4, life: 0.9 },
                    { r: 240, sp: 2.5, life: 0.8 }
                ];

                waves.forEach((w, i) => {
                    setTimeout(() => {
                        particles.push({
                            type: "shockwave",
                            x, y,
                            radius: w.r,
                            speed: w.sp,
                            life: w.life
                        });
                    }, i * 80);
                });

                for (let i = 0; i < 260; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = Math.random() * 14 + 4;

                    particles.push({
                        x, y,
                        vx: Math.cos(ang) * sp,
                        vy: Math.sin(ang) * sp,
                        life: 1.2,
                        color,
                        size: Math.random() * 3.2 + 1.2
                    });
                }

                setTimeout(() => {

                    particles.push({
                        type: "flash",
                        life: 0.9,
                        color: "rgba(0,0,0,0.85)"
                    });

                    particles.push({
                        type: "shockwave",
                        x, y,
                        radius: Math.max(WIDTH, HEIGHT),
                        speed: -10,
                        life: 1.4
                    });

                    for (let i = 0; i < 180; i++) {
                        const ang = Math.random() * Math.PI * 2;
                        const r = Math.random() * 260 + 60;
                        const sp = Math.random() * 6 + 3;

                        particles.push({
                            x: x + Math.cos(ang) * r,
                            y: y + Math.sin(ang) * r,
                            vx: -Math.cos(ang + Math.PI / 6) * sp,
                            vy: -Math.sin(ang + Math.PI / 6) * sp,
                            life: 1.3,
                            color: "#ffffff",
                            size: Math.random() * 2.2 + 0.8
                        });
                    }

                    if (typeof playBlackHoleSound === "function") {
                        playBlackHoleSound();
                    }

                }, 520);

                playExplosionSound();
                setTimeout(playExplosionSound, 180);
                setTimeout(playExplosionSound, 420);

            }

            /* =====================================================
             * Collision: merge logic
             * - same index and not BlackHole -> merge into next level
             * - when BlackHole is created -> supernova + clear
             * ===================================================== */

            Events.on(engine, "collisionStart", (e) => {
                if (!isGameRunning || isClearing) return;

                e.pairs.forEach(p => {
                    const a = p.bodyA;
                    const b = p.bodyB;

                    // indexがない、または既に合体処理中（isMerging）なら無視
                    if (a.index === undefined || b.index === undefined || a.isMerging || b.isMerging) return;

                    // 同じ種類の惑星のみ合体、かつ最大サイズ（ブラックホール）でないこと
                    if (a.index !== b.index || a.index >= PLANETS.length - 1) return;

                    // --- 合体処理開始のロック ---
                    a.isMerging = true;
                    b.isMerging = true;

                    const mid = {
                        x: (a.position.x + b.position.x) / 2,
                        y: (a.position.y + b.position.y) / 2
                    };

                    const nI = a.index + 1;
                    const nP = PLANETS[nI];

                    // 次のフレームで即座に削除（衝突判定の重複を防ぐ）
                    Composite.remove(engine.world, [a, b]);

                    /* ===============================
                     * 演出: 音・パーティクル・重力波
                     * =============================== */
                    playExplosionSound();

                    // 重力波: 周囲の惑星をわずかに弾き飛ばす
                    const allBodies = Composite.allBodies(engine.world);
                    allBodies.forEach(body => {
                        if (body.isStatic || body.isMerging) return;
                        const dx = body.position.x - mid.x;
                        const dy = body.position.y - mid.y;
                        const distSq = dx * dx + dy * dy;
                        const forceRadius = 150; // 効果範囲

                        if (distSq < forceRadius * forceRadius) {
                            const dist = Math.sqrt(distSq);
                            const forceMagnitude = 0.003 * body.mass; // 弾く強さ
                            Body.applyForce(body, body.position, {
                                x: (dx / dist) * forceMagnitude,
                                y: (dy / dist) * forceMagnitude
                            });
                        }
                    });

                    // パーティクル演出
                    particles.push({
                        type: "shockwave",
                        x: mid.x, y: mid.y,
                        radius: 10, speed: 5, life: 1
                    });

                    for (let i = 0; i < 12; i++) {
                        const ang = Math.random() * Math.PI * 2;
                        const s = Math.random() * 4 + 2;
                        particles.push({
                            x: mid.x, y: mid.y,
                            vx: Math.cos(ang) * s,
                            vy: Math.sin(ang) * s,
                            life: 1, color: nP.color, size: 3
                        });
                    }

                    /* ===============================
                     * スコア計算 (コンボシステム)
                     * =============================== */
                    const now = Date.now();
                    if (now - lastMergeTime < 800) { // 0.8秒以内の合体でコンボ
                        comboCount++;
                    } else {
                        comboCount = 0;
                    }
                    lastMergeTime = now;

                    // コンボ倍率を適用（例: 2回目は1.2倍、3回目は1.4倍...）
                    const comboBonus = 1 + (comboCount * 0.2);
                    const points = nI === CLEAR_INDEX ? SUPERNOVA_BONUS : nP.score;
                    updateScore(Math.floor(points * comboBonus));

                    /* ===============================
                     * 合体後の新天体生成
                     * =============================== */
                    setTimeout(() => {
                        // ブラックホール（クリア判定）の場合
                        if (nI === CLEAR_INDEX) {
                            if (isClearing) return;
                            isClearing = true;
                            isBlackHoleCore = true;
                            isGameRunning = false;
                            isClickable = false;

                            triggerSupernovaAt(mid.x, mid.y, "#ffffff");
                            setTimeout(removeAllDynamicBodies, SUPERNOVA_CLEAR_DELAY);
                            setTimeout(triggerGameClear, SUPERNOVA_END_DELAY);
                        }
                        // 通常の進化
                        else {
                            const nb = Bodies.circle(mid.x, mid.y, nP.radius, {
                                index: nI,
                                restitution: 0.4,
                                friction: 0.8,
                                frictionAir: 0.02,
                                render: { visible: false }
                            });
                            Composite.add(engine.world, nb);
                        }
                    }, 40); // わずかな遅延で生成（物理挙動の安定化）
                });
            });


        }

        /* =========================================================
         * BOOST Controls
         * - mouse / touch / space key
         * ========================================================= */
        const boostBtn = document.getElementById("boost-btn");

        const clearHiBtn = document.getElementById("clear-hi-btn");


        boostBtn.addEventListener("mousedown", (e) => {
            e.stopPropagation();
            isBoosting = true;
        });

        boostBtn.addEventListener("mouseup", (e) => {
            e.stopPropagation();
            isBoosting = false;
        });

        boostBtn.addEventListener("mouseleave", () => {
            isBoosting = false;
        });

        boostBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            isBoosting = true;
        });

        boostBtn.addEventListener("touchend", (e) => {
            e.preventDefault();
            isBoosting = false;
        });

        boostBtn.addEventListener("touchcancel", () => {
            isBoosting = false;
        });

        window.addEventListener("keydown", (e) => {
            if (e.code === "Space") {
                e.preventDefault();
                isBoosting = true;
            }
        });

        window.addEventListener("keyup", (e) => {
            if (e.code === "Space") {
                isBoosting = false;
            }
        });



        /* BOOST visual feedback */
        setInterval(() => {
            boostBtn.style.boxShadow = isBoosting
                ? "0 0 20px rgba(79,172,254,0.9)"
                : "none";
        }, 50);

        /* =========================================================
         * Score
         * ========================================================= */
        function updateScore(points) {
            score += points;
            document.getElementById("score-val").innerText = score;

            if (score > hiScore) {
                hiScore = score;
                document.getElementById("hi-score-val").innerText = hiScore;
                localStorage.setItem("stellarGravity_hiScore", hiScore);
            }
        }

        /* =========================================================
         * Game Over
         * ========================================================= */
        function triggerGameOver() {
            stopBGM();

            document.getElementById("clear-message").style.display = "none";

            isGameRunning = false;
            document.getElementById("stage-val").innerText = stage;
            isContinue = false;

            document.getElementById("overlay").classList.remove("hide");
            bgmToggleBtn.style.pointerEvents = "auto";
            bgmToggleBtn.style.opacity = "0.75";

            document.querySelector("#overlay h1").innerHTML = "GAME OVER";
            document.getElementById("start-btn").textContent = "START";
            /* ★ 再表示 */
            clearHiBtn.style.display = "";

            updateResetButtonVisibility();


        }

        /* =========================================================
         * Clear
         * ========================================================= */
        function triggerGameClear() {
            const clearedStage = stage;

            onClear(); 

            stage++;

            if (stage > hiStage) {
                hiStage = stage;
                document.getElementById("hi-stage-val").innerText = hiStage;
                localStorage.setItem("stellarGravity_hiStage", hiStage);
            }

            document.getElementById("stage-val").innerText = stage;
            pendingCoreBoost = true;
            isContinue = true;
            isGameRunning = false;
            updateResetButtonVisibility();


            document.getElementById("overlay").classList.remove("hide");
            bgmToggleBtn.style.pointerEvents = "auto";
            bgmToggleBtn.style.opacity = "0.75";

            document.querySelector("#overlay h1").innerHTML = "STAGE " + clearedStage + "<br>CLEAR";
            document.getElementById("start-btn").textContent = "NEXT";

            
            clearHiBtn.style.display = "none";

            const msg = document.getElementById("clear-message");


            msg.innerHTML =
                "The core has collapsed<br>into a Black Hole.<br><br>" +

                "A new star system awaits.";

            msg.style.display = "block";


            playClearBgm();
        }

        /* =========================================================
         * Shoot (tap/click)
         * - takes nextQueue[0], pushes new random (0..3)
         * - sets initial velocity toward center (+ drift when boosting)
         * ========================================================= */
        function shoot(e) {

            if (isPaused) return;

            const reset = document.getElementById("reset-btn");
            if (e && reset && reset.contains(e.target)) return;


            if (e && isInBoostSafeArea(e.clientX, e.clientY)) return;

            if (e && document.getElementById("bgm-toggle")
                .contains(e.target)) return;

            if (!isGameRunning || !isClickable || !document.getElementById("overlay").classList.contains("hide")) return;

            isClickable = false;

            const nI = nextQueue.shift();
            nextQueue.push(Math.floor(Math.random() * 4));

            playSuctionSound();

            const sX = CENTER.x + Math.cos(launcherAngle) * SPAWN_RADIUS;
            const sY = CENTER.y + Math.sin(launcherAngle) * SPAWN_RADIUS;

            const b = Bodies.circle(sX, sY, PLANETS[nI].radius, {
                index: nI,
                restitution: 0.2,
                friction: 0.8,
                frictionAir: isBoosting ? 0.008 : 0.02,
                render: { visible: false }
            });

            const BASE_SPEED = 6 * difficulty;
            const BOOST_DRIFT = isBoosting ? 0.35 : 0;

            const vxC = -Math.cos(launcherAngle);
            const vyC = -Math.sin(launcherAngle);

            const vxT = -Math.sin(launcherAngle);
            const vyT = Math.cos(launcherAngle);

            const vx = (vxC + vxT * BOOST_DRIFT) * BASE_SPEED;
            const vy = (vyC + vyT * BOOST_DRIFT) * BASE_SPEED;

            Body.setVelocity(b, { x: vx, y: vy });

            Composite.add(engine.world, b);

            setTimeout(() => { isClickable = true; }, 600);
        }

        /* =========================================================
         * Init (create world once)
         * ========================================================= */
        preInit();

        /* =========================================================
         * Start / Next button
         * - hides overlay
         * - resets on START, continues on NEXT
         * - rebuilds world and core
         * ========================================================= */
        document.getElementById("start-btn").addEventListener("click", (e) => {

            requestFullScreen();

            // クリア音を含め、今鳴っているすべての音を即座に消去

            forceStopBGM();

            if (isPaused) {
                isPaused = false;
            }

            document.getElementById("clear-message").style.display = "none";

            isClearing = false;

            isBlackHoleCore = false;

            e.preventDefault();
            e.stopPropagation();

            if (isGameRunning) return;
            if (audioCtx.state === "suspended") audioCtx.resume();

            playBGM();

            const isNext = document.getElementById("start-btn").textContent === "NEXT";

            document.getElementById("overlay").classList.add("hide");
            bgmToggleBtn.style.pointerEvents = "none";
            bgmToggleBtn.style.opacity = "0.4";

            if (!isNext) {
                stage = 1;
                score = 0;
                CORE_RADIUS = CORE_DEFAULT;
                pendingCoreBoost = false;
                isContinue = false;

                document.getElementById("stage-val").innerText = stage;
                document.getElementById("score-val").innerText = "0";
            }

            Composite.clear(engine.world, false);

            if (isNext && pendingCoreBoost) {
                CORE_RADIUS = Math.min(CORE_MAX, CORE_RADIUS + CORE_GROW);
                pendingCoreBoost = false;
            }

            Composite.add(engine.world, Bodies.circle(CENTER.x, CENTER.y, CORE_RADIUS, {
                isStatic: true,
                render: { visible: false }
            }));

            nextQueue = [
                Math.floor(Math.random() * 4),
                Math.floor(Math.random() * 4)
            ];

            gameOverTime = null;
            isClickable = true;
            isGameRunning = true;

            updateResetButtonVisibility();
        });


        /* =========================================================
         * Reset Game Button
         * ========================================================= */

        function updateResetButtonVisibility() {
            const btn = document.getElementById("reset-btn");

            if (!btn) return;

            btn.style.display = isGameRunning ? "block" : "none";
        }


        const resetBtn = document.getElementById("reset-btn");

        function handleResetRequest(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!isGameRunning) return;

            isPaused = true;
            Runner.stop(runner);

            const ok = confirm("ゲームを中断してタイトルに戻りますか？");

            if (ok) {
                stopBGM();
                returnToTitle();
                return;
            }

            // キャンセル時のみ再開
            isPaused = false;
            Runner.run(runner, engine);
        }

        resetBtn.addEventListener("click", handleResetRequest);

        resetBtn.addEventListener("touchend", handleResetRequest, { passive: false });




        resetBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });


        resetBtn.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        /* =========================================================
         * Input
         * ========================================================= */
        window.addEventListener("mousedown", (e) => {
            if (isGameRunning && !isPaused && e.button === 0) shoot(e);
        });

        window.addEventListener("touchstart", (e) => {

            const reset = document.getElementById("reset-btn");

            if (reset && reset.contains(e.target)) {
                return;   // RESETなら完全無視
            }

            if (isGameRunning) {
                shoot(e);
                e.preventDefault();
            }
        }, { passive: false });


        /* =========================================================
         * Resize
         * ========================================================= */
        window.addEventListener("resize", () => {
            const dpr = window.devicePixelRatio || 1;

            // ★ 旧センターを保持
            const oldCenter = { ...CENTER };

            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };

            const dx = CENTER.x - oldCenter.x;
            const dy = CENTER.y - oldCenter.y;

            /* ===== Render のサイズ更新 ===== */
            render.canvas.width = WIDTH * dpr;
            render.canvas.height = HEIGHT * dpr;
            render.canvas.style.width = WIDTH + "px";
            render.canvas.style.height = HEIGHT + "px";

            render.context.setTransform(dpr, 0, 0, dpr, 0, 0);

            render.options.width = WIDTH;
            render.options.height = HEIGHT;

            /* ===== ★ 全ボディを同じ量だけ平行移動 ===== */
            Matter.Composite.allBodies(engine.world).forEach(b => {
                Matter.Body.setPosition(b, {
                    x: b.position.x + dx,
                    y: b.position.y + dy
                });
            });
        });



        /* =========================================================
         * Clear High Score / Stage (title overlay only)
         * ========================================================= */

        document.getElementById("clear-hi-btn").addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            const overlay = document.getElementById("overlay");
            if (overlay.classList.contains("hide")) return;

            if (!confirm("HIGH SCORE と STAGE をリセットしますか？")) return;

            hiScore = 0;
            hiStage = 1;

            localStorage.setItem("stellarGravity_hiScore", 0);
            localStorage.setItem("stellarGravity_hiStage", 1);

            document.getElementById("hi-score-val").innerText = "0";
            document.getElementById("hi-stage-val").innerText = "1";

            alert("HIGH SCORE をリセットしました");
        });

        /* =========================================================
         * BGM Toggle (title screen only)
         * ========================================================= */
        let isBgmEnabled = true;

        const bgmToggleBtn = document.getElementById("bgm-toggle");

        bgmToggleBtn.addEventListener("click", (e) => {
            e.stopPropagation();

            if (isGameRunning) return;

            isBgmEnabled = !isBgmEnabled;

            bgmToggleBtn.textContent = isBgmEnabled ? "BGM ON" : "BGM OFF";
            localStorage.setItem(
                "stellarGravity_bgm",
                isBgmEnabled ? "on" : "off"
            );
        });

        /* Load initial BGM setting */
        isBgmEnabled = localStorage.getItem("stellarGravity_bgm") !== "off";
        bgmToggleBtn.textContent = isBgmEnabled ? "BGM ON" : "BGM OFF";

        /* =========================================================
        * HTMLAudio BGM helpers (Refactored)
        * ========================================================= */


        let bgmFadeInterval = null;
        let currentAudio = null;
        let isBgmFading = false;


        /* ===== フェードアウト共通処理 ===== */
        function fadeOut(audio, callback) {
            if (!audio) {
                if (callback) callback();
                return;
            }

            if (bgmFadeInterval) {
                clearInterval(bgmFadeInterval);
                bgmFadeInterval = null;
            }

            isBgmFading = true;
            let vol = audio.volume;

            bgmFadeInterval = setInterval(() => {
                vol -= 0.05; // 少し速めにフェード
                if (vol > 0.05) {
                    audio.volume = vol;
                } else {
                    clearInterval(bgmFadeInterval);
                    bgmFadeInterval = null;
                    audio.pause();
                    audio.volume = 0; // 完全に0にする
                    audio.currentTime = 0;
                    isBgmFading = false;
                    if (callback) callback();
                }
            }, 30);
        }


        /* ===== 停止（現在鳴っている音をフェードアウト） ===== */
        function stopBGM(callback = null) {
            if (!currentAudio) {
                if (callback) callback();
                return;
            }

            fadeOut(currentAudio, () => {
                currentAudio = null;
                if (callback) callback();
            });
        }


        /* ===== 強制停止 ===== */
        function forceStopBGM() {
            if (bgmFadeInterval) {
                clearInterval(bgmFadeInterval);
                bgmFadeInterval = null;
            }
            isBgmFading = false;

            // すべてのオーディオ要素を配列に入れて一括停止
            [bgm, clearBgm].forEach(a => {
                a.pause();
                a.currentTime = 0;
                a.volume = 0.8; // 次回再生用にデフォルトへ
            });

            currentAudio = null;
        }

        /* ===== 通常BGM再生 ===== */
        function playBGM() {
            
            if (!isBgmEnabled) return;

            forceStopBGM();

            bgm.currentTime = 0;
            bgm.volume = 0.8;

            bgm.play().catch(() => { });

            currentAudio = bgm;
        }

        /* 修正箇所：scriptタグ内の上部、変数定義のあたりに追加 */
        function unlockAudio() {
            if (audioCtx.state === "suspended") {
                audioCtx.resume();
            }
            // 空のバッファを再生してアンロック
            const buffer = audioCtx.createBuffer(1, 1, 22050);
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start(0);

            // HTMLAudio要素も一度 play -> pause してアンロック
            bgm.play().then(() => { bgm.pause(); }).catch(() => { });
            clearBgm.play().then(() => { clearBgm.pause(); }).catch(() => { });

            // 一度実行したらイベントを削除
            window.removeEventListener('touchstart', unlockAudio);
            window.removeEventListener('mousedown', unlockAudio);
        }

        // 最初のタップ時にアンロックを実行
        window.addEventListener('touchstart', unlockAudio);
        window.addEventListener('mousedown', unlockAudio);

        /* 修正箇所：playClearBgm 関数を差し替え */
        function playClearBgm() {
            if (!isBgmEnabled) return;

            // 前の音を止める（フェードなしで即座に止めるのが確実）
            forceStopBGM();

            // iOSでは resume が必須
            if (audioCtx.state === "suspended") {
                audioCtx.resume();
            }

            // 音量をセットして再生
            clearBgm.currentTime = 0;
            clearBgm.volume = 0.3;

            const playPromise = clearBgm.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    currentAudio = clearBgm;
                }).catch(err => {
                    console.log("Audio play blocked:", err);
                    // アンロックが漏れていた場合の最終手段
                    const retryPlay = () => {
                        clearBgm.play();
                        currentAudio = clearBgm;
                        window.removeEventListener('touchstart', retryPlay);
                    };
                    window.addEventListener('touchstart', retryPlay);
                });
            }
        }




    </script>
</body>
</html>
