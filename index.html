<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Stellar Gravity</title>
    <meta name="apple-mobile-web-app-title" content="StellarGrav">


    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="StellarGrav">

    <link rel="icon" href="img/StellarGravity.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="img/StellarGravity.png">
    <link rel="icon" type="image/png" sizes="192x192" href="img/StellarGravity.png">
    <link rel="manifest" href="manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">


    <!-- =========================================================
         Physics Engine
         - Matter.js（重力・衝突・剛体など）
         ========================================================= -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <style>
        /* =========================================================
         Global / Layout
         ========================================================= */
        body {
            margin: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
            position: fixed;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            font-weight: 200 !important;
        }

        .btn {
            font-family: 'Orbitron', sans-serif;
        }



        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            display: block;
            -webkit-touch-callout: none;
        }

        /* =========================================================
         HUD (Top Score / Next)
         ========================================================= */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px 10px 20px 25px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
            font-weight: normal;
        }

        .hud-item {
            margin-bottom: 12px;
        }

        .hud-label {
            font-size: 18px;
            color: #aaa;
            letter-spacing: 1px;
            display: inline-block;
            margin-bottom: 2px;
            justify-content: space-between;
        }

        .score-num {
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 15px #4facfe;
            display: block;
            font-weight: normal;
        }

        .hi-score-num {
            font-size: 32px;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241,196,15,0.5);
            font-weight: normal;
        }

        /* ハイスコア横の「STAGE」という文字と数字を含むエリア全体の調整 */
        .hi-stage-text {
            margin-left: 12px;
            font-size: 12px;
            color: #aaa;
            letter-spacing: 1px;
            font-weight: normal;
            vertical-align: baseline; /* 数字を大きくした際のズレを防止 */
        }

        #hi-stage-val {
            font-size: 26px;
            color: #fff;
            margin-left: 2px;
            position: relative;
            top: 2px;
            font-weight: bold;
        }

        #next-name {
            margin-top: 5px;
            font-size: 15px;
            letter-spacing: 1px;
            line-height: 1.1;
            opacity: 0.9;
            text-shadow: 0 0 6px rgba(255,255,255,0.4);
        }

        /* =========================================================
         Overlay (Title / Result)
         ========================================================= */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            text-align: center;
            transition: opacity 0.5s;
        }

            #overlay.hide {
                opacity: 0;
                pointer-events: none;
            }

        h1 {
            margin: 0;
            font-size: 42px;
            line-height: 1.1;
            letter-spacing: 6px;
            font-weight: 200;
        }

        .btn {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.8);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            letter-spacing: 4px;
        }

            .btn:hover {
                background: white;
                color: black;
            }

        .sub-btn {
            margin-top: 32px; /* 16px から 32px へ拡大 */
            padding: 10px 16px;
            font-size: 13px; /* 少しだけ小さくして控えめに */
            letter-spacing: 2px;
            opacity: 0.6; /* 通常時の透明度を下げて誤操作を誘発しにくく */
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 20px;
            transition: opacity 0.3s, background 0.3s;
        }

            .sub-btn:hover {
                opacity: 1.0;
                background: rgba(255, 0, 0, 0.4); /* ホバー時は少し赤くして警告感を出す */
            }

        /* =========================================================
         Bottom Left: BOOST
         ========================================================= */
        #boost-btn {
            position: fixed;
            bottom: 70px; /* 固定 */
            left: 32px;
            padding: 10px 25px;
            font-size: 20px;
            letter-spacing: 2px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 30px;
            cursor: pointer;
            z-index: 20;
            box-shadow: inset 0 0 12px rgba(255,255,255,0.25);
            isolation: isolate;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
        }

            #boost-btn::before {
                content: "";
                position: absolute;
                inset: -15px;
                border-radius: 100px;
                border: 3px solid rgba(79,172,254,0.8);
                box-shadow: 0 0 25px rgba(79,172,254,0.5);
                pointer-events: none;
                z-index: -1;
            }

        /* =========================================================
         Bottom Right Area: Management & Stage
         ========================================================= */
        #bottom-right-ui {
            position: fixed;
            right: 24px;
            bottom: 60px; /* BOOSTボタンのbottomと同じ値にして下揃えに */
            display: flex;
            align-items: flex-end; /* 下端で揃える */
            gap: 20px;
            pointer-events: none;
            z-index: 1000;
        }

        #management-btn-area {
            position: relative;
            width: 110px;
            height: 45px; /* サイズは維持 */
            pointer-events: auto;
            /* 下揃えを確実にするため、余計なmargin等がないか確認 */
            margin-bottom: 0;
        }

        #reset-btn, #bgm-control-pos {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
        }

        /* BGMとReset共通の基本スタイル */
        #reset-btn, #bgm-toggle {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.6); /* 境界線を少し太く */
            border-radius: 20px;
            font-size: 10px; /* 少し大きく */
            letter-spacing: px;
            cursor: pointer;
            outline: none;
            -webkit-tap-highlight-color: transparent; /* タップ時の青い枠を消す */
            transition: background 0.1s, transform 0.05s;
        }

        /* Resetボタン専用：より目立たせ、押しやすくする */
        #reset-btn {
            display: none;
            background: rgba(150, 0, 0, 0.7); /* 警告色として少し赤暗く */
            border-color: rgba(255, 100, 100, 0.8);
        }

            /* 押した瞬間のフィードバック（「効いてる」感） */
            #reset-btn:active, #bgm-toggle:active {
                transform: scale(0.95); /* 少しへこむ演出 */
                background: rgba(255, 255, 255, 0.3);
            }

        #exit-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            opacity: 1.0;
        }

        #stage-ui {
            text-align: right;
            pointer-events: none;
        }

        .stage-label {
            font-size: 12px;
            letter-spacing: 2px;
            color: #aaa;
        }

        .stage-num {
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(255,255,255,0.6);
        }

        /* タイトル時にSTAGEをグレーアウトさせるためのスタイル */
        .ui-faded {
            opacity: 0.3;
            transition: opacity 0.5s;
        }

        /* スコアが加算された時のアニメーション修正 */
        .score-bounce {
            animation: score-bounce 0.5s ease-out;
        }

        /* その他UI共通 */
        #controls-hint {
            font-family: 'Orbitron', sans-serif;
            font-weight: 400;
        }

        @keyframes score-bounce {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            30% {
                transform: scale(1.1);
                opacity: 0.8;
                text-shadow: 0 0 10px #fff;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>

</head>

<body>

    <!-- =========================================================
         BGM (loop)
         ========================================================= -->
    <audio id="game-bgm" loop preload="auto"></audio>
    <audio id="clear-bgm" src="audio/StellarGravity_Clear.mp3" preload="auto"></audio>
    <audio id="title-bgm" src="audio/StellarGravity_Title.mp3" loop preload="auto"></audio>


    <!-- Matter.js canvas is injected here -->
    <div id="canvas-container"></div>

    <!-- =========================================================
         HUD
         ========================================================= -->
    <div id="ui-layer" style="padding: 20px 10px 20px 20px;">
        <div style="text-align:left;">
            <div class="hud-item">
                <span class="hud-label">HIGH SCORE</span><br />
                <span id="hi-score-val" class="hi-score-num">0</span>
                <span class="hi-stage-text">STAGE <span id="hi-stage-val">1</span></span>
            </div>
            <div class="hud-item">
                <span class="hud-label">SCORE</span><br />
                <span id="score-val" class="score-num">0</span>
            </div>
        </div>

        <div style="text-align: right; margin-right: -5px;">
            <div style="display: inline-flex; flex-direction: column; align-items: center; min-width: 100px;">
                <span style="font-size:20px; color:#aaa; letter-spacing:2px; margin-bottom: 2px;">NEXT</span>

                <div id="next-ui" style="height:55px; width:60px; margin: 0 auto;"></div>

                <div id="timer-bar-container" style="width: 80px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; margin-top: 8px; display: none; overflow: hidden;">
                    <div id="timer-bar-fill" style="width: 100%; height: 100%; background: #ff3c3c; box-shadow: 0 0 10px #ff0000;"></div>
                </div>

                <div id="next-name" style="margin-top: 2px; font-size:15px; letter-spacing:1px; font-weight: bold; line-height: 1.1;"></div>
            </div>
        </div>

    </div>

    <!-- =========================================================
         Overlay (title / result)
         - BGM ON/OFF is title-screen-only (inside overlay)
         ========================================================= -->
    <div id="overlay">
        <h1 id="title-text">STELLAR<br />GRAVITY</h1>

        <div id="controls-hint" style="margin-top: 25px; font-size: 10px; letter-spacing: 2px; color: #888; line-height: 1.6;">
            [PC] ENTER / UP : SHOOT | SPACE : BOOST<br>
            [TOUCH] TAP SCREEN : SHOOT
        </div>

        <button id="start-btn" class="btn">START</button>
        <button id="exit-btn" class="btn sub-btn" style="display: block; margin: 20px auto 0; opacity: 0.8;">CREDITS</button>

        <button id="clear-hi-btn" class="btn sub-btn">CLEAR HIGH SCORE</button>
        <p id="clear-message" style="margin-top:20px; font-size:16px; letter-spacing:1px; opacity:0.9; display:none;"></p>
    </div>

    <!-- =========================================================
         BUTTON
         ========================================================= -->
    <button id="boost-btn">BOOST</button>

    <div id="bottom-right-ui" style="position: fixed; right: 24px; bottom: 60px; display: flex; align-items: flex-end; gap: 0px; pointer-events: none; z-index: 1000;">

        <div id="management-btn-area" style="pointer-events: auto; position: relative; width: 100px; height: 30px;">
            <button id="reset-btn">RESET</button>
            <div id="bgm-control-pos">
                <button id="bgm-toggle" class="btn sub-btn" style="margin-top: 0; width: 100%; height: 100%; padding: 0;">BGM ON</button>
            </div>
        </div>

        <div id="stage-ui" class="ui-faded" style="text-align: right; pointer-events: none;">
            <div class="stage-label">STAGE</div>
            <div id="stage-val" class="stage-num">1</div>
        </div>
    </div>


    <script>
        /* =========================================================
         * Stellar Gravity
         * ---------------------------------------------------------
         * Game Summary:
         * - Center core (sun-like)
         * - Launcher rotates around center automatically
         * - Tap/click to shoot a planet toward center
         * - Same size (same index) merges into next level
         * - If any planet stays outside DEADLINE for 3 sec -> Game Over
         * - Grow to BlackHole -> Clear
         * ========================================================= */

        /* =========================================================
         * iOS 判定（起動時に1回だけ）
         * ========================================================= */
        const isIOS =
            /iPhone|iPad|iPod/.test(navigator.userAgent) ||
            (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);


        /* =========================================================
         * Constants / Tuning
         * ========================================================= */
        const SUPERNOVA_BONUS = 3000;
        const SUPERNOVA_CLEAR_DELAY = 450;
        const SUPERNOVA_END_DELAY = 1100;

        const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;



        /* =========================================================
         * ゲーム変数
         * ========================================================= */
        let isClearing = false;
        let isPaused = false;

        const gameBgmEl = document.getElementById("game-bgm"); // ゲーム中オーディオ要素
        const clearBgm = document.getElementById("clear-bgm");
        const titleBgm = document.getElementById("title-bgm");


        /* =========================================================
         * Screen / Center
         * ========================================================= */
        let WIDTH = window.innerWidth;
        let HEIGHT = window.innerHeight;
        let CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };

        /* =========================================================
         * Difficulty Radii
         * - CORE_RADIUS:   center core radius
         * - DEADLINE_RADIUS: danger threshold
         * - SPAWN_RADIUS: launcher distance from center
         * ========================================================= */
        const DEADLINE_RADIUS = 180;
        const SPAWN_RADIUS = 220;

        // RedZone visual tuning
        const REDZONE_ROT_SPEED = 0.0015;   // 回転速度
        const REDZONE_SPARK_RATE = 0.12;    // 火花発生率


        /* Core growth on stage clear */
        const CORE_DEFAULT = 45;
        const CORE_MAX = 85;
        const CORE_GROW = 10;
        let CORE_RADIUS = CORE_DEFAULT;

        /* State flags related to stage clear / continue */
        let pendingCoreBoost = false;
        let isContinue = false;


        /* =========================================================
         * Rotation Boost
         * ========================================================= */
        let isBoosting = false;
        const ROTATE_BASE_SPEED = 0.015;
        const ROTATE_BOOST_MULT = 3.5;
        const STAR_BOOST_MULT = 3.0;
        const STAR_BASE_SPEED = 6.0;

        let clearCount = 0;
        let difficulty = 1.0;

        const DIFF_STEP = 0.12;   // 1クリアごとの上昇量
        const DIFF_MAX = 3.0;    // 上限

        /* =========================================================
         * 10面以降のショット制限タイマー設定
         * ========================================================= */
        let shotTimer = null;
        let shotTimeLimit = 0; // 現在の制限時間（秒）

        /* --- タイマー設定の書き換え --- */
        const TIMER_START_STAGE = 1;      // 1面からタイマーを作動させる
        const TIMER_MAX_SEC = 30.0;       // 1面の秒数
        const TIMER_MID_SEC = 10.0;       // 6面の秒数
        const TIMER_MIN_SEC = 2.0;        // 最短の秒数

        let barAnimId = null;
        let timerStartTime = 0;

        /* =========================================================
         * Stage / Hi-Stage
         * ========================================================= */
        let stage = 1;
        document.getElementById("stage-val").innerText = stage;

        let hiStage = localStorage.getItem("stellarGravity_hiStage") || 1;
        document.getElementById("hi-stage-val").innerText = hiStage;

        /* =========================================================
         * Planet Definitions (merge levels)
         * index: 0..8
         * score: points gained when the higher planet is created
         * ========================================================= */
        const PLANETS = [
            { name: "W.Dwarf", radius: 10, color: "#aab7b8", score: 1 },  // 灰色：冷えゆく白色矮星
            { name: "Sirius.B", radius: 16, color: "#dfe6e9", score: 2 },     // 明るい灰：シリウスの伴星（白色矮星）
            { name: "B.Star", radius: 22, color: "#ff7675", score: 4 }, // 薄赤：バーナード星（赤色矮星）
            { name: "Vega", radius: 30, color: "#74b9ff", score: 8 },         // 青：こと座のベガ（青白い主系列星）
            { name: "Capella", radius: 38, color: "#a29bfe", score: 16 },    // 紫：カペラ（黄色〜紫がかった巨星のイメージ）
            { name: "Procyon", radius: 48, color: "#ffeaa7", score: 32 },    // 薄黄：プロキオン（黄白色の準巨星）
            { name: "Arcturus", radius: 58, color: "#fab1a0", score: 64 },   // 橙：アークトゥルス（オレンジ色の巨星）
            { name: "Antares", radius: 70, color: "#ff9f43", score: 128 },   // 輝く橙：アンタレス（赤色超巨星）
            { name: "BlackHole", radius: 85, color: "#ffffff", score: 256 }  // 白：ブラックホールのイベントホライズン
        ];

        /* =========================================================
         * Game State
         * ========================================================= */
        let engine, render, runner;

        let score = 0;
        let hiScore = localStorage.getItem("stellarGravity_hiScore") || 0;

        let isGameRunning = false;
        let isClickable = true;
        let nextQueue = [];
        let launcherAngle = -Math.PI / 2;

        let gameOverTime = null;
        let particles = [];
        let bgStars = [];
        let starCanvas = null; // 星を書き込む下書き用キャンバス
        let staticStarAngle = 0;    // ★追加：これがないと afterRender で止まりま

        let implosionScale = 1.0; // 恒星の伸縮倍率
        let implosionAlpha = 1.0; // 恒星の透明度
        let isImploding = false;  // 爆縮アニメーション中か


        // ★ デバッグ用：どの惑星でクリアするか
        const DEBUG_CLEAR_INDEX = 3; // Earth
        // 本番は ↓
        const CLEAR_INDEX = PLANETS.length - 1; // BlackHole
        let isBlackHoleCore = false;

        // コンボ管理用の変数
        let lastMergeTime = 0;
        let comboCount = 0;

        /* =========================================================
         * クリア時に呼ぶ
         * ========================================================= */
        function onClear() {
            clearCount++;
            difficulty = Math.min(DIFF_MAX, 1.0 + clearCount * DIFF_STEP);
        }

        /* =========================================================
         * 回転速度
         * ========================================================= */
        function applyRotation(body) {
            const base = ROTATE_BASE_SPEED * difficulty;

            const rotateSpeed = isBoosting
                ? base * ROTATE_BOOST_MULT
                : base;

            Body.setAngularVelocity(body, rotateSpeed);
        }

        function applyStarBoost(body, angle) {
            const speed =
                STAR_BASE_SPEED *
                STAR_BOOST_MULT *
                difficulty;

            Body.setVelocity(body, {
                x: Math.sin(angle) * speed,
                y: Math.cos(angle) * speed
            });
        }

        function clamp(v, min, max) {
            return Math.min(max, Math.max(min, v));
        }

        /* =========================================================
         * Shootタイマー
         * ========================================================= */
        function startShotTimer() {
            const container = document.getElementById("timer-bar-container");
            const fill = document.getElementById("timer-bar-fill");

            if (!container || !fill) return;

            if (shotTimer) {
                clearTimeout(shotTimer);
                shotTimer = null;
            }
            if (barAnimId) {
                cancelAnimationFrame(barAnimId);
                barAnimId = null;
            }

            if (!isGameRunning || isPaused) {
                container.style.display = "none";
                return;
            }

            // 秒数計算ロジック
            if (stage <= 6) {
                shotTimeLimit = TIMER_MAX_SEC - (stage - 1) * 4.0;
            } else {
                shotTimeLimit = Math.max(TIMER_MIN_SEC, TIMER_MID_SEC - (stage - 6) * 1.0);
            }

            // --- ★ここを修正: [1] にすることで「NEXT」の色を取得 ---
            // nextQueue[1] が存在しない場合の安全策として [0] も参照
            const nextPlanetIndex = nextQueue.length > 1 ? nextQueue[1] : nextQueue[0];
            const nextPlanetColor = PLANETS[nextPlanetIndex].color;

            container.style.display = "block";
            fill.style.width = "100%";
            fill.style.opacity = "1";
            fill.style.background = nextPlanetColor;
            fill.style.boxShadow = `0 0 10px ${nextPlanetColor}`;

            timerStartTime = Date.now();

            shotTimer = setTimeout(() => {
                if (isGameRunning && isClickable && !isPaused) {
                    shoot();
                }
            }, shotTimeLimit * 1000);

            function updateBar() {
                if (!isGameRunning || isPaused) return;

                const elapsed = (Date.now() - timerStartTime) / 1000;
                const remainingRatio = Math.max(0, 1 - (elapsed / shotTimeLimit));
                const remainingSec = shotTimeLimit * remainingRatio;

                fill.style.width = (remainingRatio * 100) + "%";

                // 短くなったら赤の点滅
                if (remainingRatio < 0.25 || remainingSec < 3.0) {
                    const blink = Math.sin(Date.now() * 0.02) * 0.5 + 0.5;
                    fill.style.background = "#ff0000";
                    fill.style.boxShadow = `0 0 15px #ff0000`;
                    fill.style.opacity = blink;
                } else {
                    // 通常時は「次の星」の色を維持
                    fill.style.background = nextPlanetColor;
                    fill.style.boxShadow = `0 0 10px ${nextPlanetColor}`;
                    fill.style.opacity = "1";
                }

                if (remainingRatio > 0) {
                    barAnimId = requestAnimationFrame(updateBar);
                }
            }
            barAnimId = requestAnimationFrame(updateBar);
        }

        /* =========================================================
         * requestFullScreen
         * ========================================================= */
        function requestFullScreen() {
            const el = document.documentElement;

            // 標準のAPI（AndroidやiPad用）
            if (el.requestFullscreen) {
                el.requestFullscreen();
            } else if (el.webkitRequestFullscreen) {
                el.webkitRequestFullscreen();
            } else if (isIOS) {
                // iPhone Safari用の擬似全画面対策
                window.scrollTo(0, 0); // アドレスバーを隠すためのスクロール
            }
        }


        /* =========================================================
         * ゲームタイトルに戻る (修正版)
         * ========================================================= */
        function returnToTitle() {
            Runner.stop(runner);

            isGameRunning = false;
            isPaused = false;
            isClickable = false;
            isContinue = false;

            forceStopBGM();

            Composite.clear(engine.world, false);
            Runner.run(runner, engine);

            const overlay = document.getElementById("overlay");
            overlay.classList.remove("hide");

            document.querySelector("#overlay h1").innerHTML = "STELLAR<br>GRAVITY";
            document.getElementById("start-btn").textContent = "START";
            document.getElementById("clear-message").style.display = "none";

            const clearHiBtn = document.getElementById("clear-hi-btn");
            if (clearHiBtn) clearHiBtn.style.display = "";

            bgmToggleBtn.style.pointerEvents = "auto";
            bgmToggleBtn.style.opacity = "0.75";

            updateResetButtonVisibility();
        }

        /* =========================================================
         * Audio (WebAudio for SFX)
         * ========================================================= */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let noiseBuffer = null;

        document.getElementById("hi-score-val").innerText = hiScore;

        // SFX用マスターゲイン
        const sfxMasterGain = audioCtx.createGain();
        sfxMasterGain.gain.value = 1.8;   // ← ここで効果音全体を大きく
        sfxMasterGain.connect(audioCtx.destination);


        /* =========================================================
         * Utility: BOOST safe area (avoid mis-tap shooting)
         * ========================================================= */
        function isInBoostSafeArea(clientX, clientY) {
            const rect = boostBtn.getBoundingClientRect();
            const margin = 60;

            return (
                clientX >= rect.left - margin &&
                clientX <= rect.right + margin &&
                clientY >= rect.top - margin &&
                clientY <= rect.bottom + margin
            );
        }

        /* =========================================================
         * Noise buffer (for suction / explosion ambience)
         * ========================================================= */
        function createNoiseBuffer() {
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }

        /* =========================================================
         * SFX: suction sound
         * ========================================================= */
        function playSuctionSound() {
            const t = audioCtx.currentTime;
            const drum = audioCtx.createOscillator(), g = audioCtx.createGain();

            drum.type = 'sine';

            // ★ 音程アップ
            drum.frequency.setValueAtTime(140, t);                // 100 → 140
            drum.frequency.exponentialRampToValueAtTime(45, t + 1.5); // 30 → 45

            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.6, t + 0.1);         // 少し音量も整理
            g.gain.exponentialRampToValueAtTime(0.001, t + 1.8);

            drum.connect(g);
            g.connect(sfxMasterGain);
            drum.start(t);
            drum.stop(t + 1.8);

            if (!noiseBuffer) noiseBuffer = createNoiseBuffer();
            const burst = audioCtx.createBufferSource();
            burst.buffer = noiseBuffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';

            // ★ ノイズも少し明るく
            filter.frequency.setValueAtTime(220, t); // 150 → 220

            const nG = audioCtx.createGain();
            nG.gain.setValueAtTime(0.12, t);
            nG.gain.exponentialRampToValueAtTime(0.001, t + 1.2);

            burst.connect(filter);
            filter.connect(nG);
            nG.connect(sfxMasterGain);

            burst.start(t);
            burst.stop(t + 1.2);
        }


        /* =========================================================
         * SFX: heavy explosion (merge)
         * ========================================================= */
        function playExplosionSound() {
            if (audioCtx.state === "suspended") audioCtx.resume();
            const t = audioCtx.currentTime;

            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(180, t);
            osc.frequency.exponentialRampToValueAtTime(60, t + 0.45);

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.0001, t);
            gain.gain.exponentialRampToValueAtTime(0.9, t + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.7);

            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer || (noiseBuffer = createNoiseBuffer());

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = "lowpass";
            noiseFilter.frequency.setValueAtTime(400, t);

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.15, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);

            const delay = audioCtx.createDelay(0.6);
            delay.delayTime.setValueAtTime(0.12, t);

            const feedback = audioCtx.createGain();
            feedback.gain.setValueAtTime(0.25, t);

            delay.connect(feedback);
            feedback.connect(delay);

            osc.connect(gain);
            gain.connect(sfxMasterGain);

            gain.connect(delay);
            delay.connect(sfxMasterGain);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(sfxMasterGain);

            osc.start(t);
            osc.stop(t + 0.8);

            noise.start(t);
            noise.stop(t + 0.5);
        }

        /* =========================================================
         * SFX: black hole (clear)
         * ========================================================= */
        function playBlackHoleSound() {
            if (audioCtx.state === "suspended") audioCtx.resume();
            const t = audioCtx.currentTime;

            const osc1 = audioCtx.createOscillator();
            osc1.type = "triangle";
            osc1.frequency.setValueAtTime(42, t + 0.3);
            osc1.frequency.exponentialRampToValueAtTime(18, t + 2.2);

            const gain1 = audioCtx.createGain();
            gain1.gain.setValueAtTime(0.0001, t);
            gain1.gain.exponentialRampToValueAtTime(0.45, t + 0.6);
            gain1.gain.exponentialRampToValueAtTime(0.0001, t + 2.4);

            const lfo = audioCtx.createOscillator();
            lfo.type = "sine";
            lfo.frequency.setValueAtTime(6, t);

            const lfoGain = audioCtx.createGain();
            lfoGain.gain.setValueAtTime(14, t);

            lfo.connect(lfoGain);
            lfoGain.connect(osc1.frequency);

            const boom = audioCtx.createOscillator();
            boom.type = "sine";
            boom.frequency.setValueAtTime(60, t + 2.3);
            boom.frequency.exponentialRampToValueAtTime(28, t + 2.55);

            const boomGain = audioCtx.createGain();
            boomGain.gain.setValueAtTime(0.0001, t + 2.25);
            boomGain.gain.exponentialRampToValueAtTime(1.0, t + 2.35);
            boomGain.gain.exponentialRampToValueAtTime(0.0001, t + 2.9);

            osc1.connect(gain1);
            gain1.connect(sfxMasterGain);

            boom.connect(boomGain);
            boomGain.connect(sfxMasterGain);

            osc1.start(t + 0.3);
            osc1.stop(t + 2.5);

            lfo.start(t);
            lfo.stop(t + 2.5);

            boom.start(t + 2.25);
            boom.stop(t + 3.0);
        }



        /* =========================================================
         * Drawing: planet (custom glow)
         * ========================================================= */
        function drawPlanet(ctx, x, y, r, color, time, bodyId) {
            ctx.save();
            ctx.translate(x, y);

            const pulse = Math.sin(time * 0.003 + bodyId) * 0.05 + 0.95;
            const curR = r * pulse;

            for (let i = 0; i < 3; i++) {
                const shift = Math.sin(time * 0.002 + (i * 2) + bodyId) * (r * 0.15);
                ctx.beginPath();
                ctx.arc(0, 0, curR + shift + (i * 2), 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.35 - (i * 0.1);
                ctx.fill();
            }

            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.arc(0, 0, curR, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = curR * 1.5;
            ctx.fill();

            ctx.restore();
        }

        /* =========================================================
         * Background stars
         * ========================================================= */
        const STAR_COUNT = Math.floor(80 * 1.5);
        const STAR_SIZE_MIN = 0.4;
        const STAR_SIZE_MAX = 3.0;

        const STAR_WHITE_RATIO = 0.65;
        const STAR_HUE_MIN = 180;
        const STAR_HUE_MAX = 320;
        const STAR_SAT = 90;
        const STAR_LIT = 80;

        function generateStars() {
            bgStars = [];
            const maxDimension = Math.max(WIDTH, HEIGHT) * 1.5;

            for (let i = 0; i < STAR_COUNT; i++) {
                const rand = Math.random();
                let color;
                // 色温度のシミュレーション
                if (rand < 0.6) color = `rgba(255, 255, 255, `; // 白
                else if (rand < 0.8) color = `rgba(180, 220, 255, `; // 青白
                else if (rand < 0.95) color = `rgba(255, 255, 200, `; // 黄
                else color = `rgba(255, 180, 180, `; // 赤

                const alpha = 0.2 + Math.random() * 0.6;

                bgStars.push({
                    r: Math.random() * maxDimension,
                    angle: Math.random() * Math.PI * 2,
                    size: STAR_SIZE_MIN + Math.random() * (STAR_SIZE_MAX - STAR_SIZE_MIN),
                    color: color + alpha + ")"
                });
            }

            starCanvas = document.createElement('canvas');
            const size = maxDimension * 2;
            starCanvas.width = size;
            starCanvas.height = size;
            const sCtx = starCanvas.getContext('2d');

            bgStars.forEach(s => {
                sCtx.fillStyle = s.color;
                // 大きい星には微かなグローを追加
                if (s.size > 2.0) {
                    sCtx.shadowBlur = 4;
                    sCtx.shadowColor = s.color;
                }
                sCtx.beginPath();
                sCtx.arc(size / 2 + Math.cos(s.angle) * s.r, size / 2 + Math.sin(s.angle) * s.r, s.size, 0, Math.PI * 2);
                sCtx.fill();
                sCtx.shadowBlur = 0;
            });
        }

        /* =========================================================
         * Pre-initialize world / renderer / loop events
         * ========================================================= */
        function preInit() {
            generateStars();

            engine = Engine.create({
                gravity: { x: 0, y: 0, scale: 0 },
                enableSleeping: false // ボディが勝手に止まってマージしなくなるのを防ぐ
            });

            render = Render.create({
                element: document.getElementById("canvas-container"),
                engine: engine,
                options: {
                    width: WIDTH,
                    height: HEIGHT,
                    wireframes: false,
                    background: "transparent"
                }
            });

            Render.run(render);
            runner = Runner.create({
                isFixed: true,  // 物理演算を一定周期にする
                delta: 1000 / 60
            });
            Runner.run(runner, engine);

            /* =====================================================
             * Render loop: afterRender
             * - rotate launcher
             * - draw background / guideline / core / planets / particles
             * - deadline + game over check
             * ===================================================== */
            Events.on(render, "afterRender", () => {
                const ctx = render.context;
                const now = Date.now();

                if (isGameRunning) {
                    const base = ROTATE_BASE_SPEED * difficulty;
                    const speed = isBoosting
                        ? base * ROTATE_BOOST_MULT
                        : base;
                    launcherAngle += speed;
                }


                // 1. まず現在の恒星名を表示するロジック（恒星名が正しく出るように）
                if (nextQueue.length >= 2) {
                    const nextPlanet = PLANETS[nextQueue[1]];
                    document.getElementById("next-name").textContent = nextPlanet.name;
                    document.getElementById("next-name").style.color = nextPlanet.color; // 名前も星の色に合わせると綺麗です
                }

                // 背景の星を描画
                if (starCanvas) {
                    const mult = isBoosting ? STAR_BOOST_MULT : 1.0;
                    staticStarAngle -= 0.0025 * mult; // 定義した変数を使用

                    ctx.save();
                    ctx.translate(CENTER.x, CENTER.y);
                    ctx.rotate(staticStarAngle);
                    ctx.drawImage(starCanvas, -starCanvas.width / 2, -starCanvas.height / 2);
                    ctx.restore();
                }

                ctx.globalAlpha = 1;

                /* =====================================================
                 * RedZone (animated dash rotation) & Warning Logic
                 * ===================================================== */
                const t = performance.now();

                // ★ 追加: 警告状態の判定
                const isWarning = gameOverTime !== null;

                ctx.save();
                ctx.translate(CENTER.x, CENTER.y);

                ctx.beginPath();
                ctx.arc(0, 0, DEADLINE_RADIUS, 0, Math.PI * 2);
                ctx.setLineDash([10, 14]);

                // 回転
                ctx.lineDashOffset = -(t * 0.02) % 1000;

                // ★ 修正: 点滅ロジックの強化
                // 警告時はベースの透明度を上げ、周期を速くする
                const blinkBase = isWarning ? 0.7 : 0.3;
                const blinkFreq = isWarning ? 0.015 : 0.006;
                const blink = blinkBase + (1 - blinkBase) * (0.5 + 0.5 * Math.sin(t * blinkFreq));

                ctx.strokeStyle = isWarning ? `rgba(255, 0, 0, ${blink})` : `rgba(255, 60, 60, ${blink})`;
                ctx.lineWidth = isWarning ? 4 : 2; // 警告時は線を太く
                ctx.stroke();

                // 外側グロー
                ctx.beginPath();
                ctx.setLineDash([]);
                ctx.arc(0, 0, DEADLINE_RADIUS + 3, 0, Math.PI * 2);
                // 警告時はグローも赤く強くする
                ctx.strokeStyle = isWarning ? `rgba(255, 0, 0, ${blink * 0.5})` : "rgba(255, 80, 80, 0.25)";
                ctx.lineWidth = isWarning ? 10 : 6;
                ctx.stroke();

                ctx.restore();


                /* =====================================================
                 * RedZone sparks
                 * ===================================================== */
                // ★ 修正: 警告時は火花の発生率を上げる
                const SPARK_RATE = isWarning ? 0.8 : (isIOS ? 0.25 : 0.45);
                const SPARK_MAX = 220;

                if (particles.length > SPARK_MAX) particles.splice(0, particles.length - SPARK_MAX);

                if (Math.random() < SPARK_RATE) {
                    const burst = 2 + (isBoosting ? 4 : 2);

                    for (let k = 0; k < burst; k++) {
                        const ang = Math.random() * Math.PI * 2;
                        const r = DEADLINE_RADIUS + (Math.random() * 10 - 5);
                        const x = CENTER.x + Math.cos(ang) * r;
                        const y = CENTER.y + Math.sin(ang) * r;

                        const sp = (isBoosting ? 5.0 : 3.2) * (0.6 + Math.random() * 0.8);
                        const ox = Math.cos(ang) * sp + (Math.random() - 0.5) * 1.0;
                        const oy = Math.sin(ang) * sp + (Math.random() - 0.5) * 1.0;

                        particles.push({
                            type: "spark",
                            x, y,
                            px: x, py: y,
                            vx: ox,
                            vy: oy,
                            life: 1.0,
                            size: 1.5 + Math.random() * 2.5,
                            color: isWarning ? "rgba(255, 255, 255, 1)" : "rgba(255,60,60,1)" // 警告時は白混ぜて輝かせる
                        });
                    }
                }



                /* core (star / black hole) */
                ctx.save();
                ctx.translate(CENTER.x, CENTER.y);

                const currentRadius = CORE_RADIUS * implosionScale;

                if (isImploding) {
                    // ===== アニメーション中：爆縮する恒星 =====
                    ctx.globalAlpha = implosionAlpha;
                    const gR = currentRadius * 3;
                    const grad = ctx.createRadialGradient(0, 0, currentRadius, 0, 0, gR);
                    grad.addColorStop(0, "rgba(255, 120, 50, 0.9)");
                    grad.addColorStop(1, "rgba(255, 0, 0, 0)");
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, gR, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "#fff700";
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
                else if (isBlackHoleCore) {
                    // ===== 爆縮後：完成したブラックホール =====
                    const t2 = performance.now() * 0.002;
                    // 外側フレア
                    for (let i = 0; i < 6; i++) {
                        const r = CORE_RADIUS * (1.8 + i * 0.25);
                        const a = 0.15 + Math.sin(t2 + i) * 0.1;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255,80,40,${a})`;
                        ctx.lineWidth = 6;
                        ctx.stroke();
                    }
                    // イベントホライズン
                    const holeGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, CORE_RADIUS);
                    holeGrad.addColorStop(0, "rgba(0,0,0,1)");
                    holeGrad.addColorStop(0.6, "rgba(30,0,0,0.9)");
                    holeGrad.addColorStop(1, "rgba(0,0,0,1)");
                    ctx.fillStyle = holeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, CORE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
                else {
                    // ===== 通常時：恒星 =====
                    const gR = CORE_RADIUS * 3 + Math.sin(now * 0.008) * 5;
                    const grad = ctx.createRadialGradient(0, 0, CORE_RADIUS, 0, 0, gR);
                    grad.addColorStop(0, "rgba(255, 120, 50, 0.9)");
                    grad.addColorStop(1, "rgba(255, 0, 0, 0)");
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, gR, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, CORE_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = "#fff700";
                    ctx.fill();
                }

                ctx.restore();


                /* draw planets (custom) */
                Composite.allBodies(engine.world).forEach(b => {
                    if (!b.isStatic && b.index !== undefined) {
                        drawPlanet(ctx, b.position.x, b.position.y, b.circleRadius, PLANETS[b.index].color, now, b.id);
                    }
                });

                /* launcher guide + next preview */
                if (isGameRunning) {
                    // 1. 発射台（ランチャー）の描画
                    if (isClickable) {
                        const sX = CENTER.x + Math.cos(launcherAngle) * SPAWN_RADIUS;
                        const sY = CENTER.y + Math.sin(launcherAngle) * SPAWN_RADIUS;

                        ctx.save();
                        ctx.beginPath();
                        ctx.setLineDash([4, 6]);
                        ctx.strokeStyle = "rgba(180, 180, 180, 0.5)";
                        ctx.lineWidth = 1.5;
                        ctx.moveTo(sX, sY);
                        ctx.lineTo(CENTER.x, CENTER.y);
                        ctx.stroke();
                        ctx.restore();

                        // 発射待機中の星を描画
                        drawPlanet(ctx, sX, sY, PLANETS[nextQueue[0]].radius, PLANETS[nextQueue[0]].color, now, 0);
                    }

                    // 2. 右上の NEXT プレビュー（恒星名・星画像をセンタリング）
                    if (nextQueue.length >= 2) {
                        const nextPlanet = PLANETS[nextQueue[1]];

                        // --- 恒星名と色の更新 ---
                        const nameEl = document.getElementById("next-name");
                        if (nameEl) {
                            nameEl.textContent = nextPlanet.name;
                            nameEl.style.color = nextPlanet.color;
                        }

                        // --- 恒星画像の描画（HTMLのnext-ui位置を自動取得） ---
                        const nextUiEl = document.getElementById("next-ui");
                        if (nextUiEl) {
                            const rect = nextUiEl.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;

                            ctx.save();
                            ctx.translate(centerX, centerY);
                            // 右端で窮屈に見えるなら、倍率を 0.7 程度に下げると余白が生まれます
                            drawPlanet(ctx, 0, 0, nextPlanet.radius * 0.7, nextPlanet.color, now, 1);
                            ctx.restore();
                        }
                    }
                }

                /* particles */

                // 最大パーティクル数を制限（スマホでのカクつき防止）
                const MAX_PARTICLES = isIOS ? 150 : 300;
                if (particles.length > MAX_PARTICLES) {
                    particles.splice(0, particles.length - MAX_PARTICLES);
                }

                /* particles loop */
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];

                    // 1. 寿命（life）の減衰を一括管理
                    if (p.type === "flash") {
                        p.life -= 0.07;
                    } else if (p.type === "spark") {
                        p.life -= 0.04;
                    } else {
                        p.life -= 0.02;
                    }

                    // 2. 寿命が尽きたらその場で削除して次のループへ
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    // 3. 座標の更新（共通処理）
                    p.px = p.x; // spark用に前の座標を保存（軌跡用）
                    p.py = p.y;
                    p.x += (p.vx || 0);
                    p.y += (p.vy || 0);

                    // 4. タイプ別の描画処理
                    if (p.type === "shockwave") {
                        p.radius += (p.speed || 0) * 0.5;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255,255,255,${p.life})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();

                    } else if (p.type === "flash") {
                        ctx.save();
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color || "rgba(255,255,255,1)";
                        ctx.fillRect(0, 0, WIDTH, HEIGHT);
                        ctx.restore();

                    } else if (p.type === "spark") {
                        ctx.save();
                        ctx.globalCompositeOperation = "lighter";
                        ctx.globalAlpha = p.life;

                        // 赤いストリーク（線）
                        ctx.strokeStyle = p.color || "rgba(255,60,60,1)";
                        ctx.lineWidth = 2.2;
                        ctx.beginPath();
                        ctx.moveTo(p.px, p.py);
                        ctx.lineTo(p.x, p.y);
                        ctx.stroke();

                        // コア（点）
                        ctx.fillStyle = "rgba(255,120,120,1)";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                    } else if (p.type === "combo-dust") {
                        // --- 【追加】コンボ用：グロー付きの白い粒 ---
                        ctx.save();
                        ctx.shadowBlur = 10;           // 光の広がり
                        ctx.shadowColor = "#ffffff";   // 光の色
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = "#ffffff";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();

                        // 中心に少し強い光を重ねる
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = p.life * 0.8;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                    } else {
                        // 通常のパーティクル
                        ctx.save();
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                /* =====================================================
                 * Game Over Check
                 * - if any planet center goes outside DEADLINE for > 3s
                 * ===================================================== */
                let isOut = false;
                Composite.allBodies(engine.world).forEach(b => {
                    if (!b.isStatic && b.index !== undefined) {
                        const d = Math.sqrt((b.position.x - CENTER.x) ** 2 + (b.position.y - CENTER.y) ** 2);
                        if (d > DEADLINE_RADIUS) isOut = true;
                    }
                });

                if (isOut && isGameRunning) {
                    if (!gameOverTime) gameOverTime = now;
                    if (now - gameOverTime > 3000) triggerGameOver();
                } else {
                    gameOverTime = null;
                }
            });

            /* =====================================================
             * Physics loop: beforeUpdate
             * - apply custom gravity toward CENTER
             * ===================================================== */
            Events.on(engine, "beforeUpdate", () => {
                Composite.allBodies(engine.world).forEach(b => {
                    if (b.isStatic) return;

                    // 1. 画面外に異常に離れたボディを削除（安全策）
                    if (Math.abs(b.position.x - CENTER.x) > WIDTH || Math.abs(b.position.y - CENTER.y) > HEIGHT) {
                        Composite.remove(engine.world, b);
                        return;
                    }

                    const dx = CENTER.x - b.position.x;
                    const dy = CENTER.y - b.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const force = 0.0028 * b.mass;

                    Body.applyForce(b, b.position, { x: (dx / dist) * force, y: (dy / dist) * force });
                });
            });

            /* =====================================================
             * Helpers: remove all dynamic bodies
             * ===================================================== */
            function removeAllDynamicBodies() {
                const bodies = Composite.allBodies(engine.world).filter(b => !b.isStatic);
                if (bodies.length) Composite.remove(engine.world, bodies);
            }

            /* =====================================================
             * Supernova effect (BlackHole clear)
             * ===================================================== */
            function triggerSupernovaAt(x, y, color = "#ffffff") {

                isImploding = true; // 爆縮開始
                implosionScale = 1.0;
                implosionAlpha = 1.0;

                let startTime = performance.now();

                const animateImplosion = (now) => {
                    const elapsed = now - startTime;

                    if (elapsed < 300) {
                        // 1. 膨張 (予兆)
                        implosionScale = 1.0 + (elapsed / 300) * 0.5;
                    } else if (elapsed < 900) {
                        // 2. 爆縮 (一気に収縮)
                        const p = (elapsed - 300) / 600;
                        implosionScale = 1.5 * (1 - p);
                        implosionAlpha = 1 - p;
                    } else {
                        // 3. 終了
                        isImploding = false; // ここで描画をブラックホールモードに完全移行
                        implosionScale = 0;
                        return;
                    }
                    requestAnimationFrame(animateImplosion);
                };
                requestAnimationFrame(animateImplosion);

                // フラッシュなどの演出は既存のまま
                particles.push({ type: "flash", life: 1.0, color: "rgba(255,255,255,1)" });

                particles.push({ type: "flash", life: 1.0, color: "rgba(255,255,255,1)" });
                setTimeout(() => {
                    particles.push({ type: "flash", life: 0.6, color: "rgba(255,200,150,0.8)" });
                }, 120);
                setTimeout(() => {
                    particles.push({ type: "flash", life: 0.35, color: "rgba(255,120,80,0.6)" });
                }, 300);

                const waves = [
                    { r: 10, sp: 10, life: 1.2 },
                    { r: 40, sp: 8, life: 1.1 },
                    { r: 90, sp: 6, life: 1.0 },
                    { r: 160, sp: 4, life: 0.9 },
                    { r: 240, sp: 2.5, life: 0.8 }
                ];

                waves.forEach((w, i) => {
                    setTimeout(() => {
                        particles.push({
                            type: "shockwave",
                            x, y,
                            radius: w.r,
                            speed: w.sp,
                            life: w.life
                        });
                    }, i * 80);
                });

                for (let i = 0; i < 260; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = Math.random() * 14 + 4;

                    particles.push({
                        x, y,
                        vx: Math.cos(ang) * sp,
                        vy: Math.sin(ang) * sp,
                        life: 1.2,
                        color,
                        size: Math.random() * 3.2 + 1.2
                    });
                }

                setTimeout(() => {

                    particles.push({
                        type: "flash",
                        life: 0.9,
                        color: "rgba(0,0,0,0.85)"
                    });

                    particles.push({
                        type: "shockwave",
                        x, y,
                        radius: Math.max(WIDTH, HEIGHT),
                        speed: -10,
                        life: 1.4
                    });

                    for (let i = 0; i < 180; i++) {
                        const ang = Math.random() * Math.PI * 2;
                        const r = Math.random() * 260 + 60;
                        const sp = Math.random() * 6 + 3;

                        particles.push({
                            x: x + Math.cos(ang) * r,
                            y: y + Math.sin(ang) * r,
                            vx: -Math.cos(ang + Math.PI / 6) * sp,
                            vy: -Math.sin(ang + Math.PI / 6) * sp,
                            life: 1.3,
                            color: "#ffffff",
                            size: Math.random() * 2.2 + 0.8
                        });
                    }

                    if (typeof playBlackHoleSound === "function") {
                        playBlackHoleSound();
                    }

                }, 520);

                playExplosionSound();
                setTimeout(playExplosionSound, 180);
                setTimeout(playExplosionSound, 420);

            }

            /* =====================================================
             * Collision: merge logic
             * - same index and not BlackHole -> merge into next level
             * - when BlackHole is created -> supernova + clear
             * ===================================================== */

            Events.on(engine, "collisionStart", (e) => {
                if (!isGameRunning || isClearing) return;

                e.pairs.forEach(p => {
                    const a = p.bodyA;
                    const b = p.bodyB;

                    // indexがない、または既に合体処理中（isMerging）なら無視
                    if (a.index === undefined || b.index === undefined || a.isMerging || b.isMerging) return;

                    // 同じ種類の惑星のみ合体、かつ最大サイズ（ブラックホール）でないこと
                    if (a.index !== b.index || a.index >= PLANETS.length - 1) return;

                    // --- 合体処理開始のロック ---
                    a.isMerging = true;
                    b.isMerging = true;

                    const mid = {
                        x: (a.position.x + b.position.x) / 2,
                        y: (a.position.y + b.position.y) / 2
                    };

                    const nI = a.index + 1;
                    const nP = PLANETS[nI];

                    // 次のフレームで即座に削除（衝突判定の重複を防ぐ）
                    Composite.remove(engine.world, [a, b]);

                    /* ===============================
                     * 演出: 音・パーティクル・重力波
                     * =============================== */
                    playExplosionSound();

                    // 重力波: 周囲の惑星をわずかに弾き飛ばす
                    const allBodies = Composite.allBodies(engine.world);
                    allBodies.forEach(body => {
                        if (body.isStatic || body.isMerging) return;
                        const dx = body.position.x - mid.x;
                        const dy = body.position.y - mid.y;
                        const distSq = dx * dx + dy * dy;
                        const forceRadius = 150; // 効果範囲

                        if (distSq < forceRadius * forceRadius) {
                            const dist = Math.sqrt(distSq);
                            const forceMagnitude = 0.003 * body.mass; // 弾く強さ
                            Body.applyForce(body, body.position, {
                                x: (dx / dist) * forceMagnitude,
                                y: (dy / dist) * forceMagnitude
                            });
                        }
                    });

                    // パーティクル演出
                    particles.push({
                        type: "shockwave",
                        x: mid.x, y: mid.y,
                        radius: 10, speed: 5, life: 1
                    });

                    for (let i = 0; i < 12; i++) {
                        const ang = Math.random() * Math.PI * 2;
                        const s = Math.random() * 4 + 2;
                        particles.push({
                            x: mid.x, y: mid.y,
                            vx: Math.cos(ang) * s,
                            vy: Math.sin(ang) * s,
                            life: 1, color: nP.color, size: 3
                        });
                    }

                    /* ===============================
                     * スコア計算 (コンボシステム)
                     * =============================== */
                    const now = Date.now();
                    if (now - lastMergeTime < 800) { // 0.8秒以内の合体でコンボ
                        comboCount++;
                    } else {
                        comboCount = 0;
                    }
                    lastMergeTime = now;

                    // コンボ倍率を適用（例: 2回目は1.2倍、3回目は1.4倍...）
                    const comboBonus = 1 + (comboCount * 0.2);
                    const points = nI === CLEAR_INDEX ? SUPERNOVA_BONUS : nP.score;
                    updateScore(Math.floor(points * comboBonus));
                    showComboText(mid.x, mid.y, comboCount);

                    /* ===============================
                     * 合体後の新天体生成
                     * =============================== */
                    setTimeout(() => {
                        // ブラックホール（クリア判定）の場合
                        if (nI === CLEAR_INDEX) {
                            if (isClearing) return;
                            isClearing = true;
                            isBlackHoleCore = true;
                            isGameRunning = false;
                            isClickable = false;

                            triggerSupernovaAt(mid.x, mid.y, "#ffffff");
                            setTimeout(removeAllDynamicBodies, SUPERNOVA_CLEAR_DELAY);
                            setTimeout(triggerGameClear, SUPERNOVA_END_DELAY);
                        }
                        // 通常の進化
                        else {
                            const nb = Bodies.circle(mid.x, mid.y, nP.radius, {
                                index: nI,
                                restitution: 0.4,
                                friction: 0.8,
                                frictionAir: 0.02,
                                render: { visible: false }
                            });
                            Composite.add(engine.world, nb);
                        }
                    }, 40); // わずかな遅延で生成（物理挙動の安定化）
                });
            });


        }

        /* =========================================================
         * BOOST Controls
         * - mouse / touch / space key
         * ========================================================= */
        const boostBtn = document.getElementById("boost-btn");

        const clearHiBtn = document.getElementById("clear-hi-btn");


        boostBtn.addEventListener("mousedown", (e) => {
            e.stopPropagation();
            isBoosting = true;
        });

        boostBtn.addEventListener("mouseup", (e) => {
            e.stopPropagation();
            isBoosting = false;
        });

        boostBtn.addEventListener("mouseleave", () => {
            isBoosting = false;
        });

        boostBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation(); // 他のタッチ判定（window）に影響を与えない
            isBoosting = true;
        }, { passive: false });

        boostBtn.addEventListener("touchend", (e) => {
            e.preventDefault();
            e.stopPropagation();
            isBoosting = false;
        }, { passive: false });

        boostBtn.addEventListener("touchcancel", () => {
            isBoosting = false;
        });

        window.addEventListener("keydown", (e) => {
            if (isPaused) return;

            // --- BOOST (Spaceキー) ---
            if (e.code === "Space") {
                e.preventDefault();
                isBoosting = true;
            }

            // --- SHOOT (Enterキー または 上矢印キー) ---
            if (e.code === "Enter" || e.code === "ArrowUp") {
                e.preventDefault();
                // ゲーム実行中かつオーバーレイが隠れている時のみ発射
                if (isGameRunning && document.getElementById("overlay").classList.contains("hide")) {
                    shoot(e);
                }
            }
        });

        window.addEventListener("keyup", (e) => {
            if (e.code === "Space") {
                isBoosting = false;
            }
        });



        /* BOOST visual feedback */
        setInterval(() => {
            boostBtn.style.boxShadow = isBoosting
                ? "0 0 20px rgba(79,172,254,0.9)"
                : "none";
        }, 50);

        /* =========================================================
         * Score
         * ========================================================= */
        function updateScore(points) {
            score += points;
            document.getElementById("score-val").innerText = score;

            if (score > hiScore) {
                hiScore = score;
                document.getElementById("hi-score-val").innerText = hiScore;
                localStorage.setItem("stellarGravity_hiScore", hiScore);
            }
        }


        /* =========================================================
        * showComboText: 洗練された白のグロー演出
        * - 発生した瞬間にグロー付きパーティクルが弾ける
        * - メッセージは2秒かけて優雅に真上に消える
        * ========================================================= */
        function showComboText(x, y, count, bonusScore) {
            if (count < 1) return;
            const comboEl = document.createElement("div");

            // シンプルかつ洗練された2行構成
            comboEl.innerHTML = `
                    <div style="font-size: 18px; letter-spacing: 5px; font-weight: 200;">COMBO +${count + 1}</div>
                `;

            // 基本スタイル（固定座標、中央揃え）
            comboEl.style.position = "fixed";
            comboEl.style.left = `${x}px`;
            comboEl.style.top = `${y - 40}px`;
            comboEl.style.textAlign = "center";
            comboEl.style.color = "#ffffff";
            // ★ ここを修正：フォントを Orbitron に統一
            comboEl.style.fontFamily = "'Orbitron', sans-serif";
            comboEl.style.fontWeight = "bold"; 

            // 二重のグローエフェクト（眩しすぎず、視認性を確保）
            comboEl.style.textShadow = "0 0 12px rgba(255,255,255,0.9), 0 0 20px rgba(255,255,255,0.3)";

            comboEl.style.pointerEvents = "none";
            comboEl.style.zIndex = "2000";
            comboEl.style.transform = "translateX(-50%)";

            // 2秒間のフェードアウト・上昇アニメーション設定
            comboEl.style.transition = "transform 2.0s cubic-bezier(0.16, 1, 0.3, 1), opacity 2.0s ease-out";

            document.body.appendChild(comboEl);

            // ==========================================
            // 1. 即座にグローパーティクル（星屑）を発生
            // ==========================================
            if (Array.isArray(particles)) {
                for (let i = 0; i < 25; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const sp = Math.random() * 4 + 2; // ほどよい飛び散り速度

                    particles.push({
                        x: x,
                        y: y - 40,
                        vx: Math.cos(ang) * sp,
                        vy: Math.sin(ang) * sp,
                        life: 1.0,
                        color: "#ffffff",
                        size: Math.random() * 2 + 1,
                        type: "combo-dust" // afterRenderのif文で判定させる
                    });
                }
            }

            // ==========================================
            // 2. メッセージを真上に移動させながら消す
            // ==========================================
            setTimeout(() => {
                comboEl.style.transform = "translate(-50%, -100px)";
                comboEl.style.opacity = "0";
            }, 20);

            // 2秒後にHTML要素を削除（メモリ解放）
            setTimeout(() => comboEl.remove(), 2100);
        }

        /* =========================================================
         * Game Over
         * ========================================================= */
        function triggerGameOver() {
            stopBGM();

            document.getElementById("clear-message").style.display = "none";

            isGameRunning = false;
            isContinue = false;

            document.getElementById("stage-val").innerText = stage;

            document.getElementById("overlay").classList.remove("hide");
            bgmToggleBtn.style.pointerEvents = "auto";
            bgmToggleBtn.style.opacity = "0.75";

            document.querySelector("#overlay h1").innerHTML = "GAME OVER";
            document.getElementById("start-btn").textContent = "START";
            /* ★ 再表示 */
            clearHiBtn.style.display = "";

            updateResetButtonVisibility();

            // ★ ゲームオーバー時に Title BGM を流す
            if (isBgmEnabled) {
                playTitleBGM();
            }

        }

        /* =========================================================
         * Clear
         * ========================================================= */

        function triggerGameClear() {
            // 1. すべての進行中フラグを整理
            onClear();
            isClearing = true; // クリア演出中
            isGameRunning = false; // ゲームループ上の判定は停止
            isContinue = true; // 「続きから」の状態をON
            pendingCoreBoost = true; // 次回コアを大きくする予約

            // 2. 演出が終わるのを待ってからオーバーレイを表示
            // SUPERNOVA_END_DELAY（約1.1秒）に合わせて実行
            setTimeout(() => {
                const overlay = document.getElementById("overlay");
                const titleH1 = document.querySelector("#overlay h1");
                const startBtn = document.getElementById("start-btn");
                const clearMsg = document.getElementById("clear-message");

                if (overlay) {
                    overlay.classList.remove("hide"); // オーバーレイを表示

                    // タイトルを「STAGE X CLEAR」に書き換え
                    titleH1.innerHTML = "STAGE " + stage + "<br>CLEAR";

                    // ボタンを「NEXT」に変更
                    startBtn.textContent = "NEXT";

                    // メッセージを表示
                    if (clearMsg) {
                        clearMsg.innerHTML = "The core has collapsed<br>into a Black Hole.<br><br>A new star system awaits.";
                        clearMsg.style.display = "block";
                    }

                    // CREDITボタンや操作説明を隠す（続きプレイのため）
                    updateResetButtonVisibility();

                    // クリア用BGMを再生
                    playClearBgm();
                }
            }, SUPERNOVA_END_DELAY);
        }

        /* =========================================================
         * Shoot (tap/click)
         * - takes nextQueue[0], pushes new random (0..3)
         * - sets initial velocity toward center (+ drift when boosting)
         * ========================================================= */
        function shoot(e) {
            if (isPaused) return;

            // ゲーム状態のチェック
            if (!isGameRunning || !isClickable || !document.getElementById("overlay").classList.contains("hide")) return;

            // 以前の isInBoostSafeArea などのガード判定は、
            // 呼び出し側のイベントリスナー（isInsideShootArea）で行うため、ここでは削除します。

            isClickable = false;

            const nI = nextQueue.shift();
            nextQueue.push(Math.floor(Math.random() * 4));

            playSuctionSound();

            const sX = CENTER.x + Math.cos(launcherAngle) * SPAWN_RADIUS;
            const sY = CENTER.y + Math.sin(launcherAngle) * SPAWN_RADIUS;

            const b = Bodies.circle(sX, sY, PLANETS[nI].radius, {
                index: nI,
                restitution: 0.2,
                friction: 0.8,
                frictionAir: isBoosting ? 0.008 : 0.02,
                render: { visible: false }
            });

            const BASE_SPEED = 6 * difficulty;
            const BOOST_DRIFT = isBoosting ? 0.35 : 0;

            const vxC = -Math.cos(launcherAngle);
            const vyC = -Math.sin(launcherAngle);
            const vxT = -Math.sin(launcherAngle);
            const vyT = Math.cos(launcherAngle);

            const vx = (vxC + vxT * BOOST_DRIFT) * BASE_SPEED;
            const vy = (vyC + vyT * BOOST_DRIFT) * BASE_SPEED;

            Body.setVelocity(b, { x: vx, y: vy });
            Composite.add(engine.world, b);

            setTimeout(() => { isClickable = true; }, 200);

            startShotTimer();
        }

        /* =========================================================
         * Init (create world once)
         * ========================================================= */
        preInit();

        /* =========================================================
         * Start / Next button
         * - hides overlay
         * - resets on START, continues on NEXT
         * - rebuilds world and core
         * ========================================================= */
        document.getElementById("start-btn").addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            requestFullScreen();
            forceStopBGM();

            // 1. Runnerの再始動（物理演算ループの復旧）
            if (runner) {
                Runner.stop(runner);
                Runner.run(runner, engine);
            }

            // 2. 状態フラグの初期化（ここでの return は削除）
            if (isPaused) isPaused = false;
            document.getElementById("clear-message").style.display = "none";
            isClearing = false;
            isBlackHoleCore = false;
            gameOverTime = null;

            const startBtn = document.getElementById("start-btn");
            const isNext = startBtn.textContent === "NEXT";

            // 3. ステージ進行ロジック
            if (isNext) {
                stage++;
                if (stage > hiStage) {
                    hiStage = stage;
                    document.getElementById("hi-stage-val").innerText = hiStage;
                    localStorage.setItem("stellarGravity_hiStage", hiStage);
                }
            } else {
                stage = 1;
                score = 0;
                clearCount = 0;
                difficulty = 1.0;
                CORE_RADIUS = CORE_DEFAULT;
                document.getElementById("score-val").innerText = "0";
            }

            document.getElementById("stage-val").innerText = stage;
            document.getElementById("overlay").classList.add("hide");

            // 4. ワールド再構築（ここが確実に実行されることが重要）
            Composite.clear(engine.world, false);
            // エンジン内部の衝突キャッシュもクリアするとより安定します
            if (engine) Engine.clear(engine);

            if (isNext && pendingCoreBoost) {
                CORE_RADIUS = Math.min(CORE_MAX, CORE_RADIUS + CORE_GROW);
                pendingCoreBoost = false;
            }

            Composite.add(engine.world, Bodies.circle(CENTER.x, CENTER.y, CORE_RADIUS, {
                isStatic: true,
                render: { visible: false }
            }));

            // 5. キューの初期化とUI反映
            nextQueue = [Math.floor(Math.random() * 4), Math.floor(Math.random() * 4)];
            const currentPlanet = PLANETS[nextQueue[1]];
            const nameEl = document.getElementById("next-name");
            if (nameEl) {
                nameEl.textContent = currentPlanet.name;
                nameEl.style.color = currentPlanet.color;
            }

            // 6. 最後にゲーム開始フラグを立てる
            isClickable = true;
            isGameRunning = true;

            updateResetButtonVisibility();
            playBGM();

            startShotTimer();
        });

        /* =========================================================
                 * UIの表示切り替え（BGM ↔ RESET ＆ STAGEグレーアウト ＆ EXIT制御）
                 * ========================================================= */
        function updateResetButtonVisibility() {
            const rBtn = document.getElementById("reset-btn");
            const bPos = document.getElementById("bgm-control-pos");
            const stageUi = document.getElementById("stage-ui");
            const exitBtn = document.getElementById("exit-btn");
            const clearHiBtn = document.getElementById("clear-hi-btn"); // 追加：ハイスコアリセットボタン
            const hint = document.getElementById("controls-hint"); // 操作説明

            if (isGameRunning) {
                // ゲーム中
                if (rBtn) rBtn.style.display = "block";
                if (bPos) bPos.style.display = "none";
                if (stageUi) stageUi.classList.remove("ui-faded");
            } else {
                // タイトル画面（オーバーレイ表示中）
                if (rBtn) rBtn.style.display = "none";
                if (bPos) bPos.style.display = "block";
                if (stageUi) stageUi.classList.add("ui-faded");

                // --- 各種ボタン・説明の表示制御 ---
                // ステージクリア後の継続状態（isContinue）なら非表示、それ以外なら表示
                const displayStyle = isContinue ? "none" : "block";

                if (exitBtn) exitBtn.style.display = displayStyle;
                if (clearHiBtn) clearHiBtn.style.display = displayStyle; // ★ここ：クリア時は非表示に
                if (hint) hint.style.display = displayStyle;
            }
        }

        const resetBtn = document.getElementById("reset-btn");

        /* --- handleResetRequest  --- */
        function handleResetRequest(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!isGameRunning) return;

            // 一旦物理演算を止める
            isPaused = true;
            Runner.stop(runner);

            const ok = confirm("ゲームを中断してタイトルに戻りますか？");

            if (ok) {
                stopBGM();
                returnToTitle(); // タイトルに戻る（タイトル画面も全画面で表示）
                requestFullScreen(); // ★ 全画面復帰
            } else {
                // キャンセル時のみ再開
                isPaused = false;
                Runner.run(runner, engine);
                requestFullScreen(); // ★ キャンセルしてゲームに戻る際も全画面復帰
            }
        }

        // PC・マウス用
        resetBtn.addEventListener("click", handleResetRequest);

        // iPhone・スマホ専用（最速で反応させる設定）
        resetBtn.addEventListener("touchstart", (e) => {
            // ボタンに触れた瞬間にリセット処理を実行
            handleResetRequest(e);
        }, { passive: false });




        resetBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });


        resetBtn.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        /* =========================================================
         * SHOOT（発射）の有効範囲判定 (修正版)
         * 画面上部から、下部ボタン（BOOST/RESET）の上端までを有効にする
         * ========================================================= */
        function isInsideShootArea(clientX, clientY) {
            const boostRect = document.getElementById("boost-btn").getBoundingClientRect();
            const resetAreaRect = document.getElementById("management-btn-area").getBoundingClientRect();

            // 下部ボタンエリアの上端を取得
            // ボタンが上に上がったので、その少し上(30px)を境界線にします
            const deadLineTop = Math.min(boostRect.top, resetAreaRect.top) - 30;

            // Y座標が画面上端(0)から、ボタンの上端(deadLineTop)の間であれば発射許可
            return clientY > 0 && clientY < deadLineTop;
        }

        /* --- タッチ・クリック共通の入力処理 --- */
        window.addEventListener("pointerdown", (e) => {
            // ボタンそのものを触っている場合は無視
            if (e.target.tagName === "BUTTON") return;

            if (isGameRunning && !isPaused) {
                // pointerdownはマウスなら左クリック(0)、タッチなら常に0を返す
                if (e.button !== 0) return;

                // 指定したエリア内なら発射
                if (isInsideShootArea(e.clientX, e.clientY)) {
                    shoot(e);
                }
            }
        }, { passive: false });

        /* =========================================================
         * Resize (改良版)
         * ========================================================= */
        let resizeTimeout;
        window.addEventListener("resize", () => {
            // 連続して発生するリサイズイベントを間引く（デバウンス）
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const dpr = window.devicePixelRatio || 1;
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;

                // 変化が極小（アドレスバーの影響など）なら処理しない
                if (Math.abs(newWidth - WIDTH) < 5 && Math.abs(newHeight - HEIGHT) < 5) return;

                const oldCenter = { ...CENTER };

                WIDTH = newWidth;
                HEIGHT = newHeight;
                CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };

                const dx = CENTER.x - oldCenter.x;
                const dy = CENTER.y - oldCenter.y;

                /* ===== Render のサイズ更新 ===== */
                render.canvas.width = WIDTH * dpr;
                render.canvas.height = HEIGHT * dpr;
                render.canvas.style.width = WIDTH + "px";
                render.canvas.style.height = HEIGHT + "px";

                // レンダラーのオプションも同期
                render.options.width = WIDTH;
                render.options.height = HEIGHT;

                // コンテキストのスケーリングを再設定
                render.context.setTransform(dpr, 0, 0, dpr, 0, 0);

                /* ===== 全ボディを平行移動（静的・動的すべて） ===== */
                const allBodies = Matter.Composite.allBodies(engine.world);
                allBodies.forEach(b => {
                    Matter.Body.setPosition(b, {
                        x: b.position.x + dx,
                        y: b.position.y + dy
                    });
                });

                // パーティクルの位置も補正しないと画面からズレるため修正
                particles.forEach(p => {
                    p.x += dx;
                    p.y += dy;
                    if (p.px !== undefined) {
                        p.px += dx;
                        p.py += dy;
                    }
                });

            }, 100); // 100ms待ってから実行
        });



        /* =========================================================
         * Clear High Score / Stage (title overlay only)
         * ========================================================= */

        document.getElementById("clear-hi-btn").addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            const overlay = document.getElementById("overlay");
            if (overlay.classList.contains("hide")) return;

            if (!confirm("HIGH SCORE と STAGE をリセットしますか？")) return;

            hiScore = 0;
            hiStage = 1;

            localStorage.setItem("stellarGravity_hiScore", 0);
            localStorage.setItem("stellarGravity_hiStage", 1);

            document.getElementById("hi-score-val").innerText = "0";
            document.getElementById("hi-stage-val").innerText = "1";

            alert("HIGH SCORE をリセットしました");
        });


        /* =========================================================
         * 終了ボタンの処理
         * ========================================================= */
        document.getElementById("exit-btn").addEventListener("click", () => {
            if (confirm("ゲームを終了しますか？")) {
                // 任意のURLへ移動（閉じる動作の代わり）
                window.location.href = "https://github.com/Hidecade/Stellar-Gravity";
            }
        });
        /* =========================================================
         * BGM Toggle (title screen only)
         * ========================================================= */
        let isBgmEnabled = true;

        const bgmToggleBtn = document.getElementById("bgm-toggle");

        bgmToggleBtn.addEventListener("click", (e) => {
            e.stopPropagation();

            if (isGameRunning) return;

            isBgmEnabled = !isBgmEnabled;

            bgmToggleBtn.textContent = isBgmEnabled ? "BGM ON" : "BGM OFF";
            localStorage.setItem(
                "stellarGravity_bgm",
                isBgmEnabled ? "on" : "off"
            );

            // ★ リアルタイム再生・停止処理
            if (isBgmEnabled) {
                // ONにしたとき：タイトルBGMを再生
                playTitleBGM();
            } else {
                // OFFにしたとき：すべてのBGMを強制停止
                forceStopBGM();
            }
        });

        /* Load initial BGM setting */
        isBgmEnabled = localStorage.getItem("stellarGravity_bgm") !== "off";
        bgmToggleBtn.textContent = isBgmEnabled ? "BGM ON" : "BGM OFF";

        /* =========================================================
        * HTMLAudio BGM helpers (Refactored)
        * ========================================================= */


        let bgmFadeInterval = null;
        let currentAudio = null;
        let isBgmFading = false;


        /* ===== フェードアウト共通処理 ===== */
        function fadeOut(audio, callback) {
            if (!audio) {
                if (callback) callback();
                return;
            }

            if (bgmFadeInterval) {
                clearInterval(bgmFadeInterval);
                bgmFadeInterval = null;
            }

            isBgmFading = true;
            let vol = audio.volume;

            bgmFadeInterval = setInterval(() => {
                vol -= 0.05; // 少し速めにフェード
                if (vol > 0.05) {
                    audio.volume = vol;
                } else {
                    clearInterval(bgmFadeInterval);
                    bgmFadeInterval = null;
                    audio.pause();
                    audio.volume = 0; // 完全に0にする
                    audio.currentTime = 0;
                    isBgmFading = false;
                    if (callback) callback();
                }
            }, 30);
        }


        /* ===== 停止（現在鳴っている音をフェードアウト） ===== */
        function stopBGM(callback = null) {
            if (!currentAudio) {
                if (callback) callback();
                return;
            }

            fadeOut(currentAudio, () => {
                currentAudio = null;
                if (callback) callback();
            });
        }


        /* ===== 強制停止 (すべてのオーディオに対応) ===== */
        function forceStopBGM() {
            if (bgmFadeInterval) {
                clearInterval(bgmFadeInterval);
                bgmFadeInterval = null;
            }
            isBgmFading = false;

            // gameBgmEl, clearBgm, titleBgm すべてを停止
            [gameBgmEl, clearBgm, titleBgm].forEach(a => {
                if (a) {
                    a.pause();
                    a.currentTime = 0;
                    a.volume = 0.8;
                }
            });
            currentAudio = null;
        }

        /* ===== 通常BGM再生（ステージ連動版） ===== */
        function playBGM() {
            if (!isBgmEnabled) return;

            forceStopBGM();

            // 1. 計算式でインデックスを出す (0, 0, 1, 1, 2, 2, 3, 3, 3...)
            // stage 1,2 -> 0
            // stage 3,4 -> 1
            // stage 5,6 -> 2
            // stage 7以上 -> 3
            const bgmIndex = Math.min(Math.floor((stage - 1) / 2), 3);

            // 2. 文字列に変換 ("00", "01", "02", "03")
            let bgmNum = bgmIndex.toString().padStart(2, '0');


            gameBgmEl.src = `audio/StellarGravity_${bgmNum}.mp3`;
            gameBgmEl.currentTime = 0;
            gameBgmEl.volume = 0.8;
            gameBgmEl.play().catch(() => { });

            currentAudio = gameBgmEl;
        }

        /* =========================================================
         * 修正版：iOS & PC Audio Unlock Logic
         * ========================================================= */
        function unlockAudio() {
            // 1. Web Audio API (効果音用) の再開
            if (audioCtx.state === "suspended") {
                audioCtx.resume();
            }

            // 2. すべてのHTMLAudio要素を「ユーザー操作内」で一度再生して許可を得る
            const audios = [gameBgmEl, clearBgm, titleBgm];

            audios.forEach(audio => {
                if (audio) {
                    // PC/iOS両対応：音量はそのままで、一瞬再生して即停止
                    // 以前の muted = true は削除しました
                    audio.play().then(() => {
                        audio.pause();
                        audio.currentTime = 0;
                    }).catch(e => {
                        // 初回クリック前などはエラーが出るが無視してOK
                        console.log("Audio unlock interaction pending...");
                    });
                }
            });

            // 3. リスナーを削除
            window.removeEventListener('touchstart', unlockAudio);
            window.removeEventListener('mousedown', unlockAudio);
        }

        // 最初のタップ時にアンロックを実行
        window.addEventListener('touchstart', unlockAudio, { once: false });
        window.addEventListener('mousedown', unlockAudio, { once: false });

        /* 修正箇所：playClearBgm 関数を差し替え */
        function playClearBgm() {
            if (!isBgmEnabled) return;

            // 前の音を止める（フェードなしで即座に止めるのが確実）
            forceStopBGM();

            // iOSでは resume が必須
            if (audioCtx.state === "suspended") {
                audioCtx.resume();
            }

            // 音量をセットして再生
            clearBgm.currentTime = 0;
            clearBgm.volume = 0.3;

            const playPromise = clearBgm.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    currentAudio = clearBgm;
                }).catch(err => {
                    console.log("Audio play blocked:", err);
                    // アンロックが漏れていた場合の最終手段
                    const retryPlay = () => {
                        clearBgm.play();
                        currentAudio = clearBgm;
                        window.removeEventListener('touchstart', retryPlay);
                    };
                    window.addEventListener('touchstart', retryPlay);
                });
            }
        }

        /* タイトルBGM再生用 */
        function playTitleBGM() {
            if (!isBgmEnabled) return;
            forceStopBGM();
            titleBgm.play().catch(() => { });
            currentAudio = titleBgm;
        }


    </script>
</body>
</html>
